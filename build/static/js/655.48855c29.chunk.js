"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[655],{8695:(e,t,i)=>{i.d(t,{d:()=>b,g:()=>d});var s=i(7718),o=Object.defineProperty,n=(e,t,i)=>((e,t,i)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i)(e,"symbol"!=typeof t?t+"":t,i);const r=.5,a=1,l=1,c=1e9,h=5,u=25e4;async function d(e,t,i){const[o,n]=await s.e.chainFromRpc(e),r="string"==typeof t?s.b7.fromSecretKey(s.a4.decode(t)):t;if(null!=i&&i.priorityFee&&i.priorityFee.percentile&&i.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new g(e,n,r,(null==i?void 0:i.debug)??!1,(null==i?void 0:i.priorityFee)??{},(null==i?void 0:i.retries)??h,null==i?void 0:i.sendOpts)}class g{constructor(e,t,i){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h,a=arguments.length>6?arguments[6]:void 0;n(this,"_rpc"),n(this,"_chain"),n(this,"_keypair"),n(this,"_debug"),n(this,"_priorityFee"),n(this,"_maxResubmits"),n(this,"_sendOpts"),this._rpc=e,this._chain=t,this._keypair=i,this._debug=s,this._priorityFee=o,this._maxResubmits=r,this._sendOpts=a,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(e){var t;if(e instanceof s.b8)return!0;if(!(e instanceof s.b9)||!e.message.includes("Transaction simulation failed"))return!1;if(e.message.includes("Blockhash not found"))return!0;const i=null==(t=e.logs)?void 0:t.find((e=>e.startsWith("Program log: Error: ")));return!!i&&!(!i.includes("Not enough bytes")&&!i.includes("Unexpected length of input"))}async signAndSend(e){var t;let{blockhash:i,lastValidBlockHeight:o}=await s.e.latestBlock(this._rpc);const n=[];for(const l of e){const{description:e,transaction:{transaction:r,signers:c}}=l;let h;this._debug&&console.log(`Signing: ${e} for ${this.address()}`),null!=(t=this._priorityFee)&&t.percentile&&this._priorityFee.percentile>0&&(h=await m(this._rpc,r,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&p(r);for(let t=0;t<this._maxResubmits;t++)try{if((0,s.b3)(r)){if(h&&0===t){const e=s.b4.decompile(r.message);e.instructions.push(...h),r.message=e.compileToV0Message()}r.message.recentBlockhash=i,r.sign([this._keypair,...c??[]])}else h&&0===t&&r.add(...h),r.recentBlockhash=i,r.lastValidBlockHeight=o,r.partialSign(this._keypair,...c??[]);this._debug&&console.log("Submitting transactions ");const{signature:e}=await s.e.sendTxWithRetry(this._rpc,r.serialize(),this._sendOpts);n.push(e);break}catch(a){if(t===this._maxResubmits-1||!this.retryable(a))throw a;this._debug&&console.log(`Failed to send transaction on attempt ${t}, retrying: `,a);const{blockhash:e,lastValidBlockHeight:n}=await s.e.latestBlock(this._rpc);o=n,i=e}}this._debug&&console.log("Waiting for confirmation for: ",n);const r=(await Promise.all(n.map((async e=>{try{return await this._rpc.confirmTransaction({signature:e,blockhash:i,lastValidBlockHeight:o},this._rpc.commitment)}catch(t){throw console.error("Failed to confirm transaction: ",t),t}})))).filter((e=>e.value.err)).map((e=>e.value.err));if(r.length>0)throw new Error(`Failed to confirm transaction: ${r}`);return n}}function p(e){if((0,s.b3)(e)){console.log(e.signatures);const t=e.message,i=t.getAccountKeys();t.compiledInstructions.forEach((e=>{console.log("Program",i.get(e.programIdIndex).toBase58()),console.log("Data: ",s.u.encode(e.data)),console.log("Keys: ",e.accountKeyIndexes.map((e=>[e,i.get(e).toBase58()])))}))}else console.log(e.signatures),console.log(e.feePayer),e.instructions.forEach((e=>{console.log("Program",e.programId.toBase58()),console.log("Data: ",e.data.toString("hex")),console.log("Keys: ",e.keys.map((e=>[e,e.pubkey.toBase58()])))}))}async function m(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:c;const[u,d]=await Promise.all([f(e,t),b(e,t,i,o,n,h)]);return[s.b6.setComputeUnitLimit({units:u}),s.b6.setComputeUnitPrice({microLamports:d})]}async function f(e,t){var i;let o=u;try{const n=await((0,s.b3)(t),e.simulateTransaction(t));n.value.err&&console.error(`Error simulating Solana transaction: ${n.value.err}`),null!=(i=null==n?void 0:n.value)&&i.unitsConsumed&&(o=Math.round(1.2*n.value.unitsConsumed))}catch(n){console.error(`Failed to calculate compute unit limit for Solana transaction: ${n}`)}return o}async function b(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:c,u=n,d=[];if((0,s.b3)(t)){const i=(await Promise.all(t.message.addressTableLookups.map((t=>e.getAddressLookupTable(t.accountKey))))).map((e=>e.value)).filter((e=>null!==e)),s=t.message,o=s.getAccountKeys({addressLookupTableAccounts:i??void 0});d=s.compiledInstructions.flatMap((e=>e.accountKeyIndexes)).map((e=>s.isAccountWritable(e)?o.get(e):null)).filter((e=>null!==e))}else d=t.instructions.flatMap((e=>e.keys)).map((e=>e.isWritable?e.pubkey:null)).filter((e=>null!==e));try{const t=await e.getRecentPrioritizationFees({lockedWritableAccounts:d});if(t){const e=t.map((e=>e.prioritizationFee)).sort(((e,t)=>e-t)),s=Math.ceil(e.length*i);if(e.length>s){let t=e[s];o>0&&(t*=o),u=Math.max(u,t)}}}catch(g){console.error("Error fetching Solana recent fees",g)}return Math.min(Math.max(u,n),h)}},4655:(e,t,i)=>{i.r(t),i.d(t,{default:()=>n});var s=i(7718),o=i(8695);const n={Address:s.S,Platform:s.e,getSigner:o.g,protocols:{WormholeCore:()=>Promise.resolve().then(i.bind(i,7718)).then((e=>e.e3)),TokenBridge:()=>i.e(442).then(i.bind(i,5442)),CircleBridge:()=>i.e(732).then(i.bind(i,7732))},getChain:(e,t,i)=>new s.f(t,new s.e(e,(0,s.c)(e,s.g,{[t]:i})))}}}]);
//# sourceMappingURL=655.48855c29.chunk.js.map