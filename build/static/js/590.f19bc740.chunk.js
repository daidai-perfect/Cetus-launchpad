"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[590,364],{1590:(e,t,r)=>{r.r(t),r.d(t,{SuiAutomaticTokenBridge:()=>Zr,SuiTokenBridge:()=>Xr,getTokenCoinType:()=>Hr,getTokenFromTokenRegistry:()=>Qr});var n=r(7718),i=r(3016),s=(r(1364),Object.defineProperty),a=(e,t,r)=>((e,t,r)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class o{constructor(e,t,r,n){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];a(this,"transaction"),a(this,"network"),a(this,"chain"),a(this,"description"),a(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=i}}class c extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:a}=e,o=0===a.length?n:`At path: ${a.join(".")} -- ${n}`;super(i??o),null!=i&&(this.cause=o),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function u(e){return"object"==typeof e&&null!=e}function d(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function l(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${d(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*h(e,t,r,n){(function(e){return u(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const i of e){const e=l(i,t,r,n);e&&(yield e)}}function f(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return function*(){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&"type"!==t.type&&u(t.schema)&&u(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let c="valid";for(const u of t.validator(e,o))u.explanation=r.message,c="not_valid",yield[u,void 0];for(let[d,l,h]of t.entries(e,o)){const t=f(l,h,{path:void 0===d?n:[...n,d],branch:void 0===d?i:[...i,l],coerce:s,mask:a,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(l=r[1],void 0===d?e=l:e instanceof Map?e.set(d,l):e instanceof Set?e.add(l):u(e)&&(void 0!==l||d in e)&&(e[d]=l))}if("not_valid"!==c)for(const u of t.refiner(e,o))u.explanation=r.message,c="not_refined",yield[u,void 0];"valid"===c&&(yield[void 0,e])}()}class p{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=(e=>e),entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=s,this.validator=n?(e,t)=>h(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>h(i(e,t),t,this,e):()=>[]}assert(e,t){return g(e,this,t)}create(e,t){return y(e,this,t)}is(e){return w(e,this)}mask(e,t){return m(e,this,t)}validate(e){return b(e,this,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}}function g(e,t,r){const n=b(e,t,{message:r});if(n[0])throw n[0]}function y(e,t,r){const n=b(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function m(e,t,r){const n=b(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function w(e,t){return!b(e,t)[0]}function b(e,t){const r=f(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}),n=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(r);return n[0]?[new c(n[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]:[void 0,n[1]]}function v(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];const n="type"===t[0].type,i=t.map((e=>e.schema)),s=Object.assign({},...i);return n?function(e){const t=Object.keys(e);return new p({type:"type",schema:e,*entries(r){if(u(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`,coercer:e=>u(e)?{...e}:e})}(s):B(s)}function j(e,t){return new p({type:e,schema:null,validator:t})}function k(){return j("any",(()=>!0))}function T(e){return new p({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${d(e)}`})}function S(){return j("boolean",(e=>"boolean"==typeof e))}function E(){return j("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${d(e)}`))}function I(e){const t=d(e),r=typeof e;return new p({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${d(r)}`})}function x(){return j("never",(()=>!1))}function O(e){return new p({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function A(){return j("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${d(e)}`))}function B(e){const t=e?Object.keys(e):[],r=x();return new p({type:"object",schema:e||null,*entries(n){if(e&&u(n)){const i=new Set(Object.keys(n));for(const r of t)i.delete(r),yield[r,n[r],e[r]];for(const e of i)yield[e,n[e],r]}},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`,coercer:e=>u(e)?{...e}:e})}function $(e){return new p({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function U(e,t){return new p({type:"record",schema:null,*entries(r){if(u(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`})}function C(){return j("string",(e=>"string"==typeof e||`Expected a string, but received: ${d(e)}`))}function _(e){const t=x();return new p({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${d(e)}`})}function z(e){const t=e.map((e=>e.type)).join(" | ");return new p({type:"union",schema:null,coercer(t){for(const r of e){const[e,n]=r.validate(t,{coerce:!0});if(!e)return n}return t},validator(r,n){const i=[];for(const t of e){const[...e]=f(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${d(r)}`,...i]}})}function M(){return j("unknown",(()=>!0))}const P=z([B({AddressOwner:C()}),B({ObjectOwner:C()}),B({Shared:B({initial_shared_version:O(C())})}),I("Immutable")]);j("SuiJsonValue",(()=>!0));const N=z([B({u32:C()}),B({u64:C()}),B({f64:C()})]);B({attributes:U(C(),O(N)),featureFlags:U(C(),S()),maxSupportedProtocolVersion:C(),minSupportedProtocolVersion:C(),protocolVersion:C()}),z([C(),I("package")]);const R=B({digest:C(),objectId:C(),version:z([A(),C(),j("bigint",(e=>"bigint"==typeof e))])});B({owner:P,reference:R}),B({objectId:C(),sequenceNumber:C()}),B({payment:T(R),owner:C(),price:C(),budget:C()});const V=v(R,B({type:C(),owner:P,previousTransaction:C()})),D=U(C(),k()),F=U(C(),M()),W=B({type:C(),fields:D,hasPublicTransfer:S()}),G=B({disassembled:F}),K=z([v(W,B({dataType:I("moveObject")})),v(G,B({dataType:I("package")}))]),L=B({type:C(),hasPublicTransfer:S(),version:C(),bcsBytes:C()}),J=B({id:C(),moduleMap:U(C(),C())}),q=z([v(L,B({dataType:I("moveObject")})),v(J,B({dataType:I("package")}))]);BigInt(1e9);const Q=B({code:C(),error:$(C()),object_id:$(C()),parent_object_id:$(C()),version:$(C()),digest:$(C())}),H=z([B({data:O($(U(C(),C()))),error:O($(Q))}),$(U(C(),C()))]),X=B({objectId:C(),version:C(),digest:C(),type:O($(C())),content:O($(K)),bcs:O($(q)),owner:O($(P)),previousTransaction:O($(C())),storageRebate:O($(C())),display:O($(H))});B({showType:O($(S())),showContent:O($(S())),showBcs:O($(S())),showOwner:O($(S())),showPreviousTransaction:O($(S())),showStorageRebate:O($(S())),showDisplay:O($(S()))}),z([I("Exists"),I("notExists"),I("Deleted")]),T(V);const Z=B({data:O($(X)),error:O($(Q))});function Y(e){if("reference"in e)return e.reference;const t=function(e){return e.data}(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:function(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}(e)}B({objectId:C(),atCheckpoint:$(A())}),B({data:T(Z),nextCursor:$(O(C())),hasNextPage:S()}),z([B({details:X,status:I("VersionFound")}),B({details:C(),status:I("ObjectNotExists")}),B({details:R,status:I("ObjectDeleted")}),B({details:_([C(),A()]),status:I("VersionNotFound")}),B({details:B({asked_version:A(),latest_version:A(),object_id:C()}),status:I("VersionTooHigh")})]);T(z([C(),B({Object:C()})]));const ee=B({address:C(),name:C()}),te=z([I("Private"),I("Public"),I("Friend")]),re=B({abilities:T(C())}),ne=B({constraints:re,isPhantom:S()}),ie=B({TypeParameter:A()}),se=_([B({module:C(),package:C(),function:C()}),C()]);function ae(e){if(!e)return!1;if("string"==typeof e||w(e,ie)||ce(e))return!0;if("object"!=typeof e)return!1;const t=e;return!!(w(t.Reference,oe)||w(t.MutableReference,oe)||w(t.Vector,oe))}B({rank3Days:T(se),rank7Days:T(se),rank30Days:T(se)});const oe=j("SuiMoveNormalizedType",ae);function ce(e){if(!e||"object"!=typeof e)return!1;const t=e;if(!t.Struct||"object"!=typeof t.Struct)return!1;const r=t.Struct;return!("string"!=typeof r.address||"string"!=typeof r.module||"string"!=typeof r.name||!Array.isArray(r.typeArguments)||!r.typeArguments.every((e=>ae(e))))}j("SuiMoveNormalizedStructType",ce);const ue=B({visibility:te,isEntry:S(),typeParameters:T(re),parameters:T(oe),return:T(oe)}),de=B({name:C(),type:oe}),le=B({abilities:re,typeParameters:T(ne),fields:T(de)}),he=B({fileFormatVersion:A(),address:C(),name:C(),friends:T(ee),structs:U(C(),le),exposedFunctions:U(C(),ue)});function fe(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function pe(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function ge(e){if("object"==typeof e&&"Struct"in e)return e;const t=pe(e),r=fe(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}U(C(),he);var ye=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===o;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var d=t[e.charCodeAt(r)];if(255===d)return;for(var l=0,h=s-1;(0!==d||l<i)&&-1!==h;h--,l++)d+=a*u[h]>>>0,u[h]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");i=l,r++}for(var f=s-i;f!==s&&0===u[f];)f++;for(var p=new Uint8Array(n+(s-f)),g=n;f!==s;)p[g++]=u[f++];return p}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,d=new Uint8Array(c);i!==s;){for(var l=t[i],h=0,f=c-1;(0!==l||h<n)&&-1!==f;f--,h++)l+=256*d[f]>>>0,d[f]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=h,i++}for(var p=c-n;p!==c&&0===d[p];)p++;for(var g=o.repeat(r);p<c;++p)g+=e.charAt(d[p]);return g},decodeUnsafe:d,decode:function(e){var t=d(e);if(t)return t;throw new Error("Non-base"+a+" character")}}};var me=ye("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const we=(0,n.ac)(me),be=e=>we.encode(e),ve=e=>we.decode(e);function je(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}const ke=8192;function Te(e){if(e.length<ke)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=ke){const n=e.slice(r,r+ke);t+=String.fromCharCode(...n)}return btoa(t)}function Se(e){var t;const r=e.startsWith("0x")?e.slice(2):e,n=(null==(t=(r.length%2===0?r:`0${r}}`).match(/.{2}/g))?void 0:t.map((e=>parseInt(e,16))))??[];return Uint8Array.from(n)}function Ee(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function Ie(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class xe{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=function(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,!(128&i))break;r+=7}return{value:t,length:n}}(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}function Oe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:["<",">"];const[r,n]=t,i=[];let s="",a=0;for(let o=0;o<e.length;o++){const t=e[o];(t===r&&a++,t===n&&a--,0!==a||","!==t)?s+=t:(i.push(s.trim()),s="")}return i.push(s.trim()),i}class Ae{constructor(){let{size:e=1024,maxSize:t,allocateSize:r=1024}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return Be(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return Be(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return Be(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return Ie(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return be(e);case"base64":return Te(e);case"hex":return Ee(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function Be(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}var $e,Ue,Ce,_e,ze=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Me=(e,t,r)=>(ze(e,t,"read from private field"),r?r.call(e):t.get(e)),Pe=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ne=(e,t,r,n)=>(ze(e,t,"write to private field"),t.set(e,r),r);const Re=class{constructor(e){Pe(this,$e,void 0),Pe(this,Ue,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),Ne(this,$e,e.write),Ne(this,Ue,e.serialize??((e,t)=>{const r=new Ae({size:this.serializedSize(e)??void 0,...t});return Me(this,$e).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),Me(this,$e).call(this,e,t)}serialize(e,t){return this.validate(e),new We(this,Me(this,Ue).call(this,e,t))}parse(e){const t=new xe(e);return this.read(t)}transform(e){let{name:t,input:r,output:n}=e;return new Re({name:t??this.name,read:e=>n(this.read(e)),write:(e,t)=>Me(this,$e).call(this,r(e),t),serializedSize:e=>this.serializedSize(r(e)),serialize:(e,t)=>Me(this,Ue).call(this,r(e),t),validate:e=>this.validate(r(e))})}};let Ve=Re;$e=new WeakMap,Ue=new WeakMap;const De=Symbol.for("@mysten/serialized-bcs");function Fe(e){return!!e&&"object"==typeof e&&!0===e[De]}class We{constructor(e,t){Pe(this,Ce,void 0),Pe(this,_e,void 0),Ne(this,Ce,e),Ne(this,_e,t)}get[De](){return!0}toBytes(){return Me(this,_e)}toHex(){return Ee(Me(this,_e))}toBase64(){return Te(Me(this,_e))}toBase58(){return be(Me(this,_e))}parse(){return Me(this,Ce).parse(Me(this,_e))}}function Ge(e){let{size:t,...r}=e;return new Ve({...r,serializedSize:()=>t})}function Ke(e){let{readMethod:t,writeMethod:r,...n}=e;return Ge({...n,read:e=>e[t](),write:(e,t)=>t[r](e),validate:e=>{var t;if(e<0||e>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,e)}})}function Le(e){let{readMethod:t,writeMethod:r,...n}=e;return Ge({...n,read:e=>e[t](),write:(e,t)=>t[r](BigInt(e)),validate:e=>{var t;const r=BigInt(e);if(r<0||r>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${r}. Expected value in range 0-${n.maxValue}`);null==(t=n.validate)||t.call(n,r)}})}Ce=new WeakMap,_e=new WeakMap;const Je={u8:e=>Ke({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>Ke({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>Ke({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>Le({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>Le({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>Le({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>Ge({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{var r;if(null==(r=null==e?void 0:e.validate)||r.call(e,t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>function(e){let{serialize:t,...r}=e;const n=new Ve({...r,serialize:t,write:(e,t)=>{for(const r of n.serialize(e).toBytes())t.write8(r)}});return n}({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Ie(e)),...e}),bytes:(e,t)=>Ge({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>function(e){let{toBytes:t,fromBytes:r,...n}=e;return new Ve({...n,read:e=>{const t=e.readULEB(),n=e.readBytes(t);return r(n)},write:(e,r)=>{const n=t(e);r.writeULEB(n.length);for(let t=0;t<n.length;t++)r.write8(n[t])},serialize:e=>{const r=t(e),n=Ie(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{var t;if("string"!=typeof e)throw new TypeError(`Invalid ${n.name} value: ${e}. Expected string`);null==(t=n.validate)||t.call(n,e)}})}({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new Ve({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>Je.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new Ve({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{var r;if(null==(r=null==t?void 0:t.validate)||r.call(t,e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new Ve({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{var n;if(null==(n=null==t?void 0:t.validate)||n.call(t,r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new Ve({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{var t;if(null==(t=null==r?void 0:r.validate)||t.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new Ve({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:(null==i?void 0:i.read(e))??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let s=0;s<n.length;s++){const[e,a]=n[s];if(e===r)return t.writeULEB(s),void(null==a||a.write(i,t))}},...r,validate:e=>{var n;if(null==(n=null==r?void 0:r.validate)||n.call(r,e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const i=Object.keys(e);if(1!==i.length)throw new TypeError(`Expected object with one key, found ${i.length}`);const[s]=i;if(!Object.hasOwn(t,s))throw new TypeError(`Invalid enum variant ${s}`)}})},map:(e,t)=>Je.vector(Je.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>function(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return t(...r).transform({name:`${t.name}<${r.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e})},lazy:e=>function(e){let t=null;function r(){return t||(t=e()),t}return new Ve({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}(e)},qe=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof qe)return this.schema=e.schema,void(this.types=new Map(e.types));if(this.schema=e,this.registerAddressType(qe.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);!1!==e.withPrimitives&&function(e){e.registerType(Qe.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),e.registerType(Qe.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),e.registerType(Qe.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),e.registerType(Qe.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),e.registerType(Qe.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),e.registerType(Qe.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),e.registerType(Qe.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),e.registerType(Qe.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),e.registerType(Qe.HEX,(function(e,t){return e.writeVec(Array.from(Se(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return Ee(new Uint8Array(t))})),e.registerType(Qe.BASE58,(function(e,t){return e.writeVec(Array.from(ve(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return be(new Uint8Array(t))})),e.registerType(Qe.BASE64,(function(e,t){return e.writeVec(Array.from(je(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return Te(new Uint8Array(t))}))}(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new qe(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(!r)throw new Error("To pass a string to `bcs.de`, specify encoding");t=function(e,t){switch(t){case"base58":return ve(e);case"base64":return je(e);case"hex":return Se(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(t,r)}if("string"==typeof e||Array.isArray(e)){const{name:r,params:n}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,n)}if("object"==typeof e){const n=new qe(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:()=>!0;const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new Ae(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new xe(t),r,n)},_encodeRaw(e,r,s,a){if(n(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new Ve({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),a=this.getTypeInterface(i),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new Ve({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),a=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,a)}})));return t(...n).read(e)})),this}registerAddressType(e,t){switch(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"hex"){case"base64":return this.registerType(e,(function(e,t){return je(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return Te(e.readBytes(t))}));case"hex":return this.registerType(e,(function(e,t){return Se(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return Ee(e.readBytes(t))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,i);if(!(a in i))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[a]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(a[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],d,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(o[u]);this.getTypeInterface(l)._encodeRaw.call(this,e,t[c],h,o)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(t[r]);if(this.hasType(u)){o[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,d,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(a[u]);o[c]=this.getTypeInterface(l)._decodeRaw.call(this,e,h,a)}else o[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,a)}return o}))}registerEnumType(e,t){for(let a in t){let e=this.tempKey(),r=t[a];null!==r&&!Array.isArray(r)&&"string"!=typeof r&&(t[a]=e,this.registerStructType(e,r))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let d=n[u],l=r[d];if(e.write8(u),null===l)return e;let h=s.indexOf(l),f=-1===h?l:a[h];{let{name:r,params:n}=this.parseTypeName(f);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,o)}}),(function(e,t,a){let o=e.readULEB(),c=n[o],u=r[c];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${o}"`);if(null===u)return{[c]:!0};let d=s.indexOf(u),l=-1===d?u:t[d];{let{name:t,params:r}=this.parseTypeName(l);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:Oe(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let Qe=qe;Qe.U8="u8",Qe.U16="u16",Qe.U32="u32",Qe.U64="u64",Qe.U128="u128",Qe.U256="u256",Qe.BOOL="bool",Qe.VECTOR="vector",Qe.ADDRESS="address",Qe.STRING="string",Qe.HEX="hex-string",Qe.BASE58="base58-string",Qe.BASE64="base64-string";const He=32;function Xe(e){const[t,r]=e.split("::"),n=e.slice(t.length+r.length+4),i=n.includes("<")?n.slice(0,n.indexOf("<")):n,s=n.includes("<")?Oe(n.slice(n.indexOf("<")+1,n.lastIndexOf(">"))).map((e=>function(e){return e.includes("::")?Xe(e):e}(e.trim()))):[];return{address:Ze(t),module:r,name:i,typeParams:s}}function Ze(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(2*He,"0")}`}function Ye(e){return Ze(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1])}BigInt(1e9);const et="0x1",tt=Ye("0x6"),rt="0x2::sui::SUI";Ye("0x5");const nt={address:"0x2",module:"object",name:"ID"},it={address:et,module:"ascii",name:"String"},st={address:et,module:"string",name:"String"},at={address:et,module:"option",name:"Option"},ot=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function ct(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const ut=["Address","Bool","U8","U16","U32","U64","U128","U256"];function dt(e,t){if("string"==typeof e&&ut.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])ct("number",t);else if("Bool"===e)ct("boolean",t);else if("Address"===e&&(ct("string",t),t&&!function(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}(e)&&function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)===He}(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=dt(e.Vector,t?t[0]:void 0);return void 0===r?void 0:`vector<${r}>`}if("Struct"in e){if(ot(e.Struct,it))return"string";if(ot(e.Struct,st))return"utf8string";if(ot(e.Struct,nt))return"address";if(ot(e.Struct,at)){return dt({Vector:e.Struct.typeArguments[0]},t)}}}const lt=/^vector<(.+)>$/,ht=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ft{static parseFromStr(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(lt);if(r)return{vector:ft.parseFromStr(r[1],t)};const n=e.match(ht);if(n)return{struct:{address:t?Ze(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:ft.parseStructTypeArgs(n[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Oe(e).map((e=>ft.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ft.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(ft.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const pt=new Qe({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function gt(e){return Je.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function yt(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const mt=Je.bytes(He).transform({input:e=>"string"==typeof e?Se(Ze(e)):e,output:e=>Ze(Ee(e))}),wt=Je.vector(Je.u8()).transform({name:"ObjectDigest",input:e=>ve(e),output:e=>be(new Uint8Array(e))}),bt=Je.struct("SuiObjectRef",{objectId:mt,version:Je.u64(),digest:wt}),vt=Je.struct("SharedObjectRef",{objectId:mt,initialSharedVersion:Je.u64(),mutable:Je.bool()}),jt=Je.enum("ObjectArg",{ImmOrOwned:bt,Shared:vt,Receiving:bt}),kt=Je.enum("CallArg",{Pure:Je.vector(Je.u8()),Object:jt,ObjVec:Je.vector(jt)}),Tt=Je.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:Je.lazy((()=>Tt)),struct:Je.lazy((()=>Bt)),u16:null,u32:null,u256:null}),St=yt(Je.enum("Argument",{GasCoin:null,Input:Je.struct("Input",{index:Je.u16()}),Result:Je.struct("Result",{index:Je.u16()}),NestedResult:Je.struct("NestedResult",{index:Je.u16(),resultIndex:Je.u16()})})),Et=Je.struct("ProgrammableMoveCall",{package:mt,module:Je.string(),function:Je.string(),type_arguments:Je.vector(Tt),arguments:Je.vector(St)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>ft.parseFromStr(e,!0)));return{package:Ze(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ft.tagToString)})}),It=yt(Je.enum("Transaction",{MoveCall:Et,TransferObjects:Je.struct("TransferObjects",{objects:Je.vector(St),address:St}),SplitCoins:Je.struct("SplitCoins",{coin:St,amounts:Je.vector(St)}),MergeCoins:Je.struct("MergeCoins",{destination:St,sources:Je.vector(St)}),Publish:Je.struct("Publish",{modules:Je.vector(Je.vector(Je.u8())),dependencies:Je.vector(mt)}),MakeMoveVec:Je.struct("MakeMoveVec",{type:(qt=Tt,Je.enum("Option",{None:null,Some:qt})),objects:Je.vector(St)}),Upgrade:Je.struct("Upgrade",{modules:Je.vector(Je.vector(Je.u8())),dependencies:Je.vector(mt),packageId:mt,ticket:St})})),xt=Je.struct("ProgrammableTransaction",{inputs:Je.vector(kt),transactions:Je.vector(It)}),Ot=Je.enum("TransactionKind",{ProgrammableTransaction:xt,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),At=Je.enum("TransactionExpiration",{None:null,Epoch:gt()}),Bt=Je.struct("StructTag",{address:mt,module:Je.string(),name:Je.string(),typeParams:Je.vector(Tt)}),$t=Je.struct("GasData",{payment:Je.vector(bt),owner:mt,price:Je.u64(),budget:Je.u64()}),Ut=Je.struct("TransactionDataV1",{kind:Ot,sender:mt,gasData:$t,expiration:At}),Ct=Je.enum("TransactionData",{V1:Ut}),_t=Je.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),zt=Je.enum("IntentVersion",{V0:null}),Mt=Je.enum("AppId",{Sui:null}),Pt=Je.struct("Intent",{scope:_t,version:zt,appId:Mt}),Nt=Je.generic(["T"],(e=>Je.struct("IntentMessage<T>",{intent:Pt,value:e}))),Rt=Je.enum("CompressedSignature",{ED25519:Je.fixedArray(64,Je.u8()),Secp256k1:Je.fixedArray(64,Je.u8()),Secp256r1:Je.fixedArray(64,Je.u8()),ZkLogin:Je.vector(Je.u8())}),Vt=Je.enum("PublicKey",{ED25519:Je.fixedArray(32,Je.u8()),Secp256k1:Je.fixedArray(33,Je.u8()),Secp256r1:Je.fixedArray(33,Je.u8()),ZkLogin:Je.vector(Je.u8())}),Dt=Je.struct("MultiSigPkMap",{pubKey:Vt,weight:Je.u8()}),Ft=Je.struct("MultiSigPublicKey",{pk_map:Je.vector(Dt),threshold:Je.u16()}),Wt=Je.struct("MultiSig",{sigs:Je.vector(Rt),bitmap:Je.u16(),multisig_pk:Ft}),Gt=Je.vector(Je.u8()).transform({input:e=>"string"==typeof e?je(e):e,output:e=>Te(new Uint8Array(e))}),Kt=Je.struct("SenderSignedTransaction",{intentMessage:Nt(Ct),txSignatures:Je.vector(Gt)}),Lt=Je.vector(Kt,{name:"SenderSignedData"}),Jt={...Je,U8:Je.u8(),U16:Je.u16(),U32:Je.u32(),U64:Je.u64(),U128:Je.u128(),U256:Je.u256(),ULEB128:Je.uleb128(),Bool:Je.bool(),String:Je.string(),Address:mt,Argument:St,CallArg:kt,CompressedSignature:Rt,GasData:$t,MultiSig:Wt,MultiSigPkMap:Dt,MultiSigPublicKey:Ft,ObjectArg:jt,ObjectDigest:wt,ProgrammableMoveCall:Et,ProgrammableTransaction:xt,PublicKey:Vt,SenderSignedData:Lt,SenderSignedTransaction:Kt,SharedObjectRef:vt,StructTag:Bt,SuiObjectRef:bt,Transaction:It,TransactionData:Ct,TransactionDataV1:Ut,TransactionExpiration:At,TransactionKind:Ot,TypeTag:Tt,ser:pt.ser.bind(pt),de:pt.de.bind(pt),getTypeInterface:pt.getTypeInterface.bind(pt),hasType:pt.hasType.bind(pt),parseTypeName:pt.parseTypeName.bind(pt),registerAddressType:pt.registerAddressType.bind(pt),registerAlias:pt.registerAlias.bind(pt),registerBcsType:pt.registerBcsType.bind(pt),registerEnumType:pt.registerEnumType.bind(pt),registerStructType:pt.registerStructType.bind(pt),registerType:pt.registerType.bind(pt),types:pt.types};var qt;pt.registerBcsType("utf8string",(()=>Je.string({name:"utf8string"}))),pt.registerBcsType("unsafe_u64",(()=>gt())),pt.registerBcsType("enumKind",(e=>yt(e))),[mt,St,kt,Rt,$t,Wt,Dt,Ft,jt,wt,Et,xt,Vt,Lt,vt,Bt,bt,It,Ct,Ut,At,Ot,Tt].forEach((e=>{pt.registerBcsType(e.name,(()=>e))}));const Qt=z([B({ImmOrOwned:R}),B({Shared:B({objectId:C(),initialSharedVersion:z([E(),C()]),mutable:S()})}),B({Receiving:R})]),Ht=B({Pure:T(E())}),Xt=B({Object:Qt}),Zt=z([Ht,Xt]);const Yt={Pure:function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:Fe(e)?e.toBytes():Jt.ser(t,e,{maxSize:1/0}).toBytes())}},ObjectRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{ImmOrOwned:{digest:r,version:n,objectId:Ze(t)}}}},SharedObjectRef(e){let{objectId:t,mutable:r,initialSharedVersion:n}=e;return{Object:{Shared:{mutable:r,initialSharedVersion:n,objectId:Ze(t)}}}},ReceivingRef(e){let{objectId:t,digest:r,version:n}=e;return{Object:{Receiving:{digest:r,version:n,objectId:Ze(t)}}}}};function er(e){return"string"==typeof e?Ze(e):"ImmOrOwned"in e.Object?Ze(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?Ze(e.Object.Receiving.objectId):Ze(e.Object.Shared.objectId)}function tr(e,t){return y(e,t)}const rr=z([B({kind:I("Input"),index:E(),value:$(k()),type:$(I("object"))}),B({kind:I("Input"),index:E(),value:$(k()),type:I("pure")})]),nr=z([...[rr,B({kind:I("GasCoin")}),B({kind:I("Result"),index:E()}),B({kind:I("NestedResult"),index:E(),resultIndex:E()})]]),ir=B({kind:I("MoveCall"),target:j("target",C().validator),typeArguments:T(C()),arguments:T(nr)}),sr=B({kind:I("TransferObjects"),objects:T(nr),address:nr}),ar=B({kind:I("SplitCoins"),coin:nr,amounts:T(nr)}),or=B({kind:I("MergeCoins"),destination:nr,sources:T(nr)}),cr=B({kind:I("MakeMoveVec"),type:$((e=>z([B({None:z([I(!0),I(null)])}),B({Some:e})]))(U(C(),M()))),objects:T(nr)}),ur=B({kind:I("Publish"),modules:T(T(E())),dependencies:T(C())}),dr=B({kind:I("Upgrade"),modules:T(T(E())),dependencies:T(C()),packageId:C(),ticket:nr}),lr=z([...[ir,sr,ar,or,ur,dr,cr]]),hr={MoveCall:e=>tr({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},ir),TransferObjects:(e,t)=>("Input"===t.kind&&"pure"===t.type&&"object"!=typeof t.value&&(t.value=Yt.Pure(Jt.Address.serialize(t.value))),tr({kind:"TransferObjects",objects:e,address:t},sr)),SplitCoins:(e,t)=>(t.forEach((e=>{"Input"===e.kind&&"pure"===e.type&&"object"!=typeof e.value&&(e.value=Yt.Pure(Jt.U64.serialize(e.value)))})),tr({kind:"SplitCoins",coin:e,amounts:t},ar)),MergeCoins:(e,t)=>tr({kind:"MergeCoins",destination:e,sources:t},or),Publish(e){let{modules:t,dependencies:r}=e;return tr({kind:"Publish",modules:t.map((e=>"string"==typeof e?Array.from(je(e)):e)),dependencies:r.map((e=>Ye(e)))},ur)},Upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return tr({kind:"Upgrade",modules:t.map((e=>"string"==typeof e?Array.from(je(e)):e)),dependencies:r.map((e=>Ye(e))),packageId:n,ticket:i},dr)},MakeMoveVec(e){let{type:t,objects:r}=e;return tr({kind:"MakeMoveVec",type:t?{Some:ft.parseFromStr(t)}:{None:null},objects:r},cr)}};function fr(e){function t(t,r){return e(t,r)}return t.u8=t=>e(Jt.U8.serialize(t)),t.u16=t=>e(Jt.U16.serialize(t)),t.u32=t=>e(Jt.U32.serialize(t)),t.u64=t=>e(Jt.U64.serialize(t)),t.u128=t=>e(Jt.U128.serialize(t)),t.u256=t=>e(Jt.U256.serialize(t)),t.bool=t=>e(Jt.Bool.serialize(t)),t.string=t=>e(Jt.String.serialize(t)),t.address=t=>e(Jt.Address.serialize(t)),t.id=t.address,t}const pr=$(O(z([B({Epoch:E()}),B({None:z([I(!0),I(null)])})]))),gr=j("StringEncodedBigint",(e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}})),yr=B({budget:$(gr),price:$(gr),payment:$(T(R)),owner:$(C())}),mr=B({version:I(1),sender:$(C()),expiration:pr,gasConfig:yr,inputs:T(rr),transactions:T(lr)});function wr(e){return Ze(e).replace("0x","")}class br{constructor(e){this.version=1,this.sender=null==e?void 0:e.sender,this.expiration=null==e?void 0:e.expiration,this.gasConfig=(null==e?void 0:e.gasConfig)??{},this.inputs=(null==e?void 0:e.inputs)??[],this.transactions=(null==e?void 0:e.transactions)??[]}static fromKindBytes(e){const t=Jt.TransactionKind.parse(e),r="ProgrammableTransaction"in t?t.ProgrammableTransaction:null;if(!r)throw new Error("Unable to deserialize from bytes.");const n=tr({version:1,gasConfig:{},inputs:r.inputs.map(((e,t)=>tr({kind:"Input",value:e,index:t,type:w(e,Ht)?"pure":"object"},rr))),transactions:r.transactions},mr);return br.restore(n)}static fromBytes(e){var t;const r=Jt.TransactionData.parse(e),n=null==r?void 0:r.V1,i="ProgrammableTransaction"in n.kind?null==(t=null==n?void 0:n.kind)?void 0:t.ProgrammableTransaction:null;if(!n||!i)throw new Error("Unable to deserialize from bytes.");const s=tr({version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:i.inputs.map(((e,t)=>tr({kind:"Input",value:e,index:t,type:w(e,Ht)?"pure":"object"},rr))),transactions:i.transactions},mr);return br.restore(s)}static restore(e){g(e,mr);const t=new br;return Object.assign(t,e),t}static getDigestFromBytes(e){const t=function(e,t){const r=Array.from(`${e}::`).map((e=>e.charCodeAt(0))),i=new Uint8Array(r.length+t.length);return i.set(r),i.set(t,r.length),(0,n.F)(i,{dkLen:32})}("TransactionData",e);return be(t)}build(){let{maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=this.inputs.map((e=>(g(e.value,Zt),e.value))),i={ProgrammableTransaction:{inputs:n,transactions:this.transactions}};if(r)return Jt.TransactionKind.serialize(i,{maxSize:e}).toBytes();const s=(null==t?void 0:t.expiration)??this.expiration,a=(null==t?void 0:t.sender)??this.sender,o={...this.gasConfig,...null==t?void 0:t.gasConfig};if(!a)throw new Error("Missing transaction sender");if(!o.budget)throw new Error("Missing gas budget");if(!o.payment)throw new Error("Missing gas payment");if(!o.price)throw new Error("Missing gas price");const c={sender:wr(a),expiration:s||{None:!0},gasData:{payment:o.payment,owner:wr(this.gasConfig.owner??a),price:BigInt(o.price),budget:BigInt(o.budget)},kind:{ProgrammableTransaction:{inputs:n,transactions:this.transactions}}};return Jt.TransactionData.serialize({V1:c},{maxSize:e}).toBytes()}getDigest(){const e=this.build({onlyTransactionKind:!1});return br.getDigestFromBytes(e)}snapshot(){return tr(this,mr)}}var vr,jr,kr,Tr,Sr,Er,Ir,xr,Or,Ar,Br,$r,Ur,Cr,_r,zr,Mr,Pr=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Nr=(e,t,r)=>(Pr(e,t,"read from private field"),r?r.call(e):t.get(e)),Rr=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Vr=(e,t,r,n)=>(Pr(e,t,"write to private field"),t.set(e,r),r),Dr=(e,t,r)=>(Pr(e,t,"access private method"),r);const Fr={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function Wr(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const Gr=Symbol.for("@mysten/transaction"),Kr={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},Lr=1000n,Jr=class{constructor(e){Rr(this,jr),Rr(this,Tr),Rr(this,Er),Rr(this,xr),Rr(this,Ar),Rr(this,$r),Rr(this,Cr),Rr(this,zr),Rr(this,vr,void 0),Vr(this,vr,new br(e?e.blockData:void 0))}static fromKind(e){const t=new Jr;return Vr(t,vr,br.fromKindBytes("string"==typeof e?je(e):e)),t}static from(e){const t=new Jr;return"string"==typeof e&&e.startsWith("{")?Vr(t,vr,br.restore(JSON.parse(e))):Vr(t,vr,br.fromBytes("string"==typeof e?je(e):e)),t}setSender(e){Nr(this,vr).sender=e}setSenderIfNotSet(e){Nr(this,vr).sender||(Nr(this,vr).sender=e)}setExpiration(e){Nr(this,vr).expiration=e}setGasPrice(e){Nr(this,vr).gasConfig.price=String(e)}setGasBudget(e){Nr(this,vr).gasConfig.budget=String(e)}setGasOwner(e){Nr(this,vr).gasConfig.owner=e}setGasPayment(e){Nr(this,vr).gasConfig.payment=e.map((e=>m(e,R)))}get blockData(){return Nr(this,vr).snapshot()}get[Gr](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:fr(((e,t)=>Fe(e)?Dr(this,jr,kr).call(this,"pure",{Pure:Array.from(e.toBytes())}):Dr(this,jr,kr).call(this,"pure",e instanceof Uint8Array?Yt.Pure(e):t?Yt.Pure(e,t):e)))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if("object"==typeof e&&"kind"in e)return e;const t=er(e),r=Nr(this,vr).inputs.find((e=>"object"===e.type&&t===er(e.value)));return r&&w(r.value,Xt)&&"Shared"in r.value.Object&&w(e,Xt)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??Dr(this,jr,kr).call(this,"object","string"==typeof e?Ze(e):e)}objectRef(){return this.object(Yt.ObjectRef(...arguments))}receivingRef(){return this.object(Yt.ReceivingRef(...arguments))}sharedObjectRef(){return this.object(Yt.SharedObjectRef(...arguments))}add(e){return function(e){const t=[],r=r=>t[r]??(t[r]={kind:"NestedResult",index:e,resultIndex:r});return new Proxy({kind:"Result",index:e},{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(e,t){if(t in e)return Reflect.get(e,t);if(t===Symbol.iterator)return function*(){let e=0;for(;;)yield r(e),e++};if("symbol"==typeof t)return;const n=parseInt(t,10);return Number.isNaN(n)||n<0?void 0:r(n)}})}(Nr(this,vr).transactions.push(e)-1)}splitCoins(e,t){return this.add(hr.SplitCoins("string"==typeof e?this.object(e):e,t.map((e=>"number"==typeof e||"bigint"==typeof e||"string"==typeof e?this.pure.u64(e):Dr(this,Tr,Sr).call(this,e)))))}mergeCoins(e,t){return this.add(hr.MergeCoins("string"==typeof e?this.object(e):e,t.map((e=>"string"==typeof e?this.object(e):e))))}publish(e){let{modules:t,dependencies:r}=e;return this.add(hr.Publish({modules:t,dependencies:r}))}upgrade(e){let{modules:t,dependencies:r,packageId:n,ticket:i}=e;return this.add(hr.Upgrade({modules:t,dependencies:r,packageId:n,ticket:"string"==typeof i?this.object(i):i}))}moveCall(e){let{arguments:t,typeArguments:r,target:n}=e;return this.add(hr.MoveCall({arguments:null==t?void 0:t.map((e=>Dr(this,Tr,Sr).call(this,e))),typeArguments:r,target:n}))}transferObjects(e,t){return this.add(hr.TransferObjects(e.map((e=>"string"==typeof e?this.object(e):e)),"string"==typeof t?this.pure.address(t):Dr(this,Tr,Sr).call(this,t)))}makeMoveVec(e){let{type:t,objects:r}=e;return this.add(hr.MakeMoveVec({type:t,objects:r.map((e=>"string"==typeof e?this.object(e):e))}))}serialize(){return JSON.stringify(Nr(this,vr).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Dr(this,zr,Mr).call(this,e),Nr(this,vr).build({maxSizeBytes:Dr(this,Er,Ir).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await Dr(this,zr,Mr).call(this,e),Nr(this,vr).getDigest()}};let qr=Jr;vr=new WeakMap,jr=new WeakSet,kr=function(e,t){const r=Nr(this,vr).inputs.length,n=tr({kind:"Input",value:"bigint"==typeof t?String(t):t,index:r,type:e},rr);return Nr(this,vr).inputs.push(n),n},Tr=new WeakSet,Sr=function(e){return Fe(e)?this.pure(e):e},Er=new WeakSet,Ir=function(e,t){let{protocolConfig:r,limits:n}=t;if(n&&"number"==typeof n[e])return n[e];if(!r)return Fr[e];const i=null==r?void 0:r.attributes[Kr[e]];if(!i)throw new Error(`Missing expected protocol config: "${Kr[e]}"`);const s="u64"in i?i.u64:"u32"in i?i.u32:i.f64;if(!s)throw new Error(`Unexpected protocol config value found for: "${Kr[e]}"`);return Number(s)},xr=new WeakSet,Or=function(e){const t=Dr(this,Er,Ir).call(this,"maxPureArgumentSize",e);Nr(this,vr).inputs.forEach(((e,r)=>{if(w(e.value,Ht)&&e.value.Pure.length>t)throw new Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${e.value.Pure.length} bytes`)}))},Ar=new WeakSet,Br=async function(e){if(Nr(this,vr).gasConfig.payment){const t=Dr(this,Er,Ir).call(this,"maxGasObjects",e);if(Nr(this,vr).gasConfig.payment.length>t)throw new Error(`Payment objects exceed maximum amount: ${t}`)}if(e.onlyTransactionKind||Nr(this,vr).gasConfig.payment)return;const t=Nr(this,vr).gasConfig.owner??Nr(this,vr).sender,r=(await Wr(e).getCoins({owner:t,coinType:rt})).data.filter((e=>!Nr(this,vr).inputs.find((t=>!!(w(t.value,Zt)&&"Object"in t.value&&"ImmOrOwned"in t.value.Object)&&e.coinObjectId===t.value.Object.ImmOrOwned.objectId)))).slice(0,Dr(this,Er,Ir).call(this,"maxGasObjects",e)-1).map((e=>({objectId:e.coinObjectId,digest:e.digest,version:e.version})));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)},$r=new WeakSet,Ur=async function(e){e.onlyTransactionKind||Nr(this,vr).gasConfig.price||this.setGasPrice(await Wr(e).getReferenceGasPrice())},Cr=new WeakSet,_r=async function(e){const{inputs:t,transactions:r}=Nr(this,vr),n=[],i=[];if(t.forEach((e=>{"object"!==e.type||"string"!=typeof e.value||i.push({id:Ze(e.value),input:e})})),r.forEach((e=>{if("MoveCall"===e.kind&&e.arguments.some((e=>"Input"===e.kind&&!w(t[e.index].value,Zt)))&&n.push(e),"SplitCoins"===e.kind&&e.amounts.forEach((e=>{if("Input"===e.kind){const r=t[e.index];"object"!=typeof r.value&&(r.value=Yt.Pure(Jt.U64.serialize(r.value)))}})),"TransferObjects"===e.kind&&"Input"===e.address.kind){const r=t[e.address.index];"object"!=typeof r.value&&(r.value=Yt.Pure(Jt.Address.serialize(r.value)))}})),n.length&&await Promise.all(n.map((async r=>{const[n,s,a]=r.target.split("::"),o=await Wr(e).getNormalizedMoveFunction({package:Ye(n),module:s,function:a}),c=o.parameters.length>0&&function(e){var t;const r=null==(t=ge(e))?void 0:t.Struct;return"0x2"===(null==r?void 0:r.address)&&"tx_context"===(null==r?void 0:r.module)&&"TxContext"===(null==r?void 0:r.name)}(o.parameters.at(-1))?o.parameters.slice(0,o.parameters.length-1):o.parameters;if(c.length!==r.arguments.length)throw new Error("Incorrect number of arguments.");c.forEach(((e,n)=>{const s=r.arguments[n];if("Input"!==s.kind)return;const a=t[s.index];if(w(a.value,Zt))return;const o=a.value,c=dt(e,o);if(c)a.value=Yt.Pure(o,c);else{if(!(null!=ge(e)||"object"==typeof e&&"TypeParameter"in e))throw new Error(`Unknown call arg type ${JSON.stringify(e,null,2)} for value ${JSON.stringify(o,null,2)}`);if("string"!=typeof o)throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(o,null,2)}`);i.push({id:o,input:a,normalizedType:e})}}))}))),i.length){const t=[...new Set(i.map((e=>{let{id:t}=e;return t})))],r=((e,t)=>Array.from({length:Math.ceil(e.length/t)},((r,n)=>e.slice(n*t,n*t+t))))(t,50),n=(await Promise.all(r.map((t=>Wr(e).multiGetObjects({ids:t,options:{showOwner:!0}}))))).flat();let s=new Map(t.map(((e,t)=>[e,n[t]])));const a=Array.from(s).filter((e=>{let[t,r]=e;return r.error})).map((e=>{let[t,r]=e;return t}));if(a.length)throw new Error(`The following input objects are invalid: ${a.join(", ")}`);i.forEach((e=>{let{id:t,input:r,normalizedType:n}=e;var i;const a=s.get(t),o=null==(i=a.data)?void 0:i.owner,c=o&&"object"==typeof o&&"Shared"in o?o.Shared.initial_shared_version:void 0;if(c){const e=null!=n&&null==fe(n)&&null==pe(n),i=function(e){var t;return(null==(t=function(e){return"object"==typeof e&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}(e))?void 0:t.mutable)??!1}(r.value)||e||null!=n&&null!=fe(n);r.value=Yt.SharedObjectRef({objectId:t,initialSharedVersion:c,mutable:i})}else n&&function(e){const t=ge(e);return!!t&&"0x2"===t.Struct.address&&"transfer"===t.Struct.module&&"Receiving"===t.Struct.name}(n)?r.value=Yt.ReceivingRef(Y(a)):r.value=Yt.ObjectRef(Y(a))}))}},zr=new WeakSet,Mr=async function(e){if(!e.onlyTransactionKind&&!Nr(this,vr).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([Dr(this,$r,Ur).call(this,e),Dr(this,Cr,_r).call(this,e)]),!e.onlyTransactionKind&&(await Dr(this,Ar,Br).call(this,e),!Nr(this,vr).gasConfig.budget)){const t=await Wr(e).dryRunTransactionBlock({transactionBlock:Nr(this,vr).build({maxSizeBytes:Dr(this,Er,Ir).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(Dr(this,Er,Ir).call(this,"maxTxGas",e)),payment:[]}}})});if("success"!==t.effects.status.status)throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=Lr*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}Dr(this,xr,Or).call(this,e)};const Qr=async(e,t,r)=>{var s,a,o;if(!(0,n.cT)(r))throw new Error(`Invalid Sui type: ${r}`);const c=await(0,i.g)(e,t);if(!c)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const u=null==(a=null==(s=c.token_registry.fields)?void 0:s.id)?void 0:a.id;if(!u)throw new Error("Unable to fetch token registry object ID");const d=(0,n.L)(null==(o=c.token_registry)?void 0:o.type);if(!d)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:u,name:{type:`${d}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},Hr=async(e,t,r,s)=>{var a,o,c,u;const d=await(0,i.g)(e,t);if(!d)throw new Error("Unable to fetch object fields from token bridge state");const l=null==(o=null==(a=d.token_registry)?void 0:a.fields)?void 0:o.coin_types,h=null==(u=null==(c=null==l?void 0:l.fields)?void 0:c.id)?void 0:u.id;if(!h)throw new Error("Unable to fetch coin types");const f=(0,n.cU)(null==l?void 0:l.type);if(!f)throw new Error("Unable to get key type");const p=await e.getDynamicFieldObject({parentId:h,name:{type:f,value:{addr:[...r],chain:s}}});if(p.error){if("dynamicFieldNotFound"===p.error.code)return null;throw new Error(`Unexpected getDynamicFieldObject response ${p.error}`)}const g=(0,i.a)(p);if(!g)return null;if(!(0,i.i)(g))throw new Error("What?");return"value"in g?(0,n.cV)(g.value):null};class Xr{constructor(e,t,r,i){a(this,"network"),a(this,"chain"),a(this,"provider"),a(this,"contracts"),a(this,"coreBridgeObjectId"),a(this,"tokenBridgeObjectId"),a(this,"chainId"),this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=n.aj.get(e,t);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=o}static async fromRpc(e,t){const[r,n]=await i.S.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new Xr(r,n,e,s.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,n.cT)(t))throw new Error(`Invalid Sui type: ${t}`);const r=await Qr(this.provider,this.tokenBridgeObjectId,t),s=(0,i.a)(r);if(!s)throw(0,n.c8)(t);if(!(0,i.i)(s))throw new Error("Expected fields to be a MoveStruct");if(!("value"in s))throw new Error("Expected a `value` key in fields of MoveStruct");const a=s.value;if(!(0,i.b)(a))throw new Error("Expected fields to be a MoveStruct");const o=(0,n.cV)(a.type);if(t=(0,n.cV)(t),o.includes(`wrapped_asset::WrappedAsset<${t}>`)){const e=a.fields.info;if(!(0,i.b)(e))throw new Error("Expected fields to be a MoveStruct");const t=e.fields.token_address;if(!(0,i.b)(t))throw new Error("Expected fields to be a MoveStruct");if(!(0,i.i)(t.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const r=t.fields.value;if(!(0,i.b)(r))throw new Error("Expected fields to be a MoveStruct");const s=new Uint8Array(r.fields.data);return{chain:(0,n.c9)(Number(e.fields.token_chain)),address:new n.ca(s)}}throw(0,n.c8)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,n.cT)(t))throw new Error(`Invalid Sui type: ${t}`);const r=await Qr(this.provider,this.tokenBridgeObjectId,t),s=(0,i.a)(r);if(!s)throw new Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!(0,i.i)(s))throw new Error("Expected fields to be a MoveStruct");if(!("value"in s))throw new Error("Expected a `value` key in fields of MoveStruct");const a=s.value;if(!(0,i.b)(a))throw new Error("Expected fields to be a MoveStruct");const o=(0,n.cV)(a.type);if(t=(0,n.cV)(t),o.includes(`native_asset::NativeAsset<${t}>`)){const e=a.fields.token_address;if(!(0,i.b)(e))throw new Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const t=e.fields.value;if(!(0,i.b)(t))throw new Error("Expected fields to be a MoveStruct");const r=new Uint8Array(t.fields.data);return new n.ca(r)}throw new Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(e,t){const r=await Hr(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,n.a8)(e));if(!r)throw new Error(`Token ${t.toString()} not found in token registry`);return new n.Q(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,n.p)(e.address))throw new Error("Token Address required, 'native' literal not supported");const t=await Hr(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,n.a8)(e.chain));if(!t)throw(0,n.c8)((0,n.bG)(e));return(0,n.cf)(this.chain,t)}async isTransferCompleted(e){var t,r,s,a,o,c,u,d;const l=await(0,i.g)(this.provider,this.tokenBridgeObjectId);if(!l)throw new Error("Unable to fetch object fields from token bridge state");const h=null==(r=null==(t=l.consumed_vaas)?void 0:t.fields)?void 0:r.hashes,f=(0,n.cU)(null==(a=null==(s=null==h?void 0:h.fields)?void 0:s.items)?void 0:a.type);if(!f)throw new Error("Unable to get key type");const p=null==(d=null==(u=null==(c=null==(o=null==h?void 0:h.fields)?void 0:o.items)?void 0:c.fields)?void 0:u.id)?void 0:d.id;if(!p)throw new Error("Unable to fetch consumed VAAs table");const g=await this.provider.getDynamicFieldObject({parentId:p,name:{type:f,value:{data:[...(0,n.cc)(e.hash)]}}});if(!g.error)return!0;if("dynamicFieldNotFound"===g.error.code)return!1;throw new Error(`Unexpected getDynamicFieldObject response ${g.error}`)}async*createAttestation(e){const t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw new Error(`Coin metadata ID for type ${t} not found`);const[n,i]=await this.getPackageIds(),s=new qr,[a]=s.splitCoins(s.gas,[s.pure(0n)]),[o]=s.moveCall({target:`${i}::attest_token::attest_token`,arguments:[s.object(this.tokenBridgeObjectId),s.object(r.id),s.pure(0n)],typeArguments:[t]});s.moveCall({target:`${n}::publish_message::publish_message`,arguments:[s.object(this.coreBridgeObjectId),a,o,s.object(tt)]}),yield this.createUnsignedTx(s,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(e,t){const[r,s]=await this.getPackageIds(),a=t.toString(),o=Math.min(e.payload.decimals,8),c=await this.getCoinBuildOutput(r,s,o),u=await(0,i.p)(c,a);yield this.createUnsignedTx(u,"Sui.TokenBridge.PrepareCreateWrapped");let d="",l="",h="",f="",p="",g=!1;for(;!g;){await new Promise((e=>setTimeout(e,500)));const e=await this.provider.queryTransactionBlocks({filter:{FromAddress:a},options:{showObjectChanges:!0},limit:3});for(const t of e.data)if("objectChanges"in t){for(const e of t.objectChanges)(0,i.c)(e)&&void 0!==e.packageId?d=e.packageId:(0,i.d)(e)&&e.objectType.includes("WrappedAssetSetup")?(l=e.objectId,p=e.objectType.split(", ")[1].replace(">","")):(0,i.d)(e)&&e.objectType.includes("UpgradeCap")?h=e.objectId:(0,i.d)(e)&&e.objectType.includes("CoinMetadata")&&(f=e.objectId);if(""!==d&&""!==l&&""!==h&&""!==f){g=!0;break}d="",l="",h="",f=""}}const y=(0,n.cW)(d),m=new qr,[w]=m.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[m.object(this.coreBridgeObjectId),m.pure((0,i.u)((0,n.bN)(e))),m.object(tt)]}),[b]=m.moveCall({target:`${s}::vaa::verify_only_once`,arguments:[m.object(this.tokenBridgeObjectId),w]});m.moveCall({target:`${s}::create_wrapped::complete_registration`,arguments:[m.object(this.tokenBridgeObjectId),m.object(f),m.object(l),m.object(h),b],typeArguments:[y,p]}),yield this.createUnsignedTx(m,"Sui.TokenBridge.SubmitAttestation")}async*transfer(e,t,r,s,a){const o=0n,c=e.toString(),u=((0,n.p)(r)?rt:r).toString(),d=await i.S.getCoins(this.provider,e,u),[l,...h]=d.filter((e=>(0,i.e)(e.coinType,u)));if(void 0===l)throw new Error(`Coins array doesn't contain any coins of type ${u}`);const[f,p]=await this.getPackageIds(),g=new qr,[y]=(()=>{if(u===rt)return g.splitCoins(g.gas,[g.pure(s)]);{const e=g.object(l.coinObjectId);return h.length&&g.mergeCoins(e,h.map((e=>g.object(e.coinObjectId)))),g.splitCoins(e,[g.pure(s)])}})(),[m]=g.splitCoins(g.gas,[g.pure(0n)]),[w]=g.moveCall({target:`${p}::state::verified_asset`,arguments:[g.object(this.tokenBridgeObjectId)],typeArguments:[u]});if(a){if(!c)throw new Error("senderAddress is required for transfer with payload");let e=!1;const r=await(async()=>{const t=await(0,i.f)(this.provider,f,c);if(null!==t)return g.object(t);{const[t]=g.moveCall({target:`${f}::emitter::new`,arguments:[g.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[s,o]=g.moveCall({target:`${p}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,w,y,g.pure((0,n.a8)(t.chain)),g.pure(t.address.toUint8Array()),g.pure([...a]),g.pure(0)],typeArguments:[u]});g.moveCall({target:`${p}::coin_utils::return_nonzero`,arguments:[o],typeArguments:[u]});const[d]=g.moveCall({target:`${p}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[g.object(this.tokenBridgeObjectId),s],typeArguments:[u]});g.moveCall({target:`${f}::publish_message::publish_message`,arguments:[g.object(this.coreBridgeObjectId),m,d,g.object(tt)]}),e&&g.transferObjects([r],g.pure(c)),yield this.createUnsignedTx(g,"Sui.TokenBridge.TransferWithPayload")}else{const[e,r]=g.moveCall({target:`${p}::transfer_tokens::prepare_transfer`,arguments:[w,y,g.pure((0,n.a8)(t.chain)),g.pure((0,i.u)(t.address.toUint8Array())),g.pure(o),g.pure(0)],typeArguments:[u]});g.moveCall({target:`${p}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[u]});const[s]=g.moveCall({target:`${p}::transfer_tokens::transfer_tokens`,arguments:[g.object(this.tokenBridgeObjectId),e],typeArguments:[u]});g.moveCall({target:`${f}::publish_message::publish_message`,arguments:[g.object(this.coreBridgeObjectId),m,s,g.object(tt)]}),yield this.createUnsignedTx(g,"Sui.TokenBridge.Transfer")}}redeem(e,t){try{var r=this;return async function*(){const e=await Hr(r.provider,r.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,n.a8)(t.payload.token.chain));if(!e)throw new Error("Unable to fetch token coinType");const[s,a]=await r.getPackageIds(),o=new qr,[c]=o.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[o.object(r.coreBridgeObjectId),o.pure((0,i.u)((0,n.bN)(t))),o.object(tt)]}),[u]=o.moveCall({target:`${a}::vaa::verify_only_once`,arguments:[o.object(r.tokenBridgeObjectId),c]}),[d]=o.moveCall({target:`${a}::complete_transfer::authorize_transfer`,arguments:[o.object(r.tokenBridgeObjectId),u],typeArguments:[e]}),[l]=o.moveCall({target:`${a}::complete_transfer::redeem_relayer_payout`,arguments:[d],typeArguments:[e]});o.moveCall({target:`${a}::coin_utils::return_nonzero`,arguments:[l],typeArguments:[e]}),yield r.createUnsignedTx(o,"Sui.TokenBridge.Redeem")}()}catch(e){return Promise.reject(e)}}async getWrappedNative(){return(0,n.cf)(this.chain,rt)}async getPackageIds(){return Promise.all([(0,i.h)(this.provider,this.coreBridgeObjectId),(0,i.h)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){var s;if(r>8)throw new Error("Decimals is capped at 8");const a=null==(s=await(0,i.j)(this.provider,this.tokenBridgeObjectId))?void 0:s.replace("0x","");if(!a)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const o="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+a+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[n.N.encode(n.u.decode(o))],dependencies:["0x1","0x2",t,e].map((e=>Ye(e)))}}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new o(e,this.network,this.chain,t,r)}}class Zr{constructor(e,t,r,n){a(this,"network"),a(this,"chain"),a(this,"connection"),a(this,"contracts"),a(this,"tokenBridgeRelayerObjectId"),a(this,"coreBridgeObjectId"),a(this,"tokenBridgeObjectId"),a(this,"fields"),this.network=e,this.chain=t,this.connection=r,this.contracts=n;const{tokenBridge:i,tokenBridgeRelayer:s,coreBridge:o}=n;if(!i||!s||!o)throw new Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=s,this.tokenBridgeObjectId=i,this.coreBridgeObjectId=o}static async fromRpc(e,t){const[r,n]=await i.S.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch for chain ${n}: ${s.network} != ${r}`);return new Zr(r,n,e,s.contracts)}async*transfer(e,t,r,s,a){const o=new n.Q((0,n.p)(r)?i.S.nativeTokenId(this.network,this.chain).address:r).getCoinType(),{coreBridge:c,tokenBridge:u}=await this.getPackageIds(),d=new qr,l=BigInt(0),[h]=d.splitCoins(d.gas,[d.pure(l)]),[f]=await(async()=>{if((0,n.p)(r))return d.splitCoins(d.gas,[d.pure(s)]);{const t=await i.S.getCoins(this.connection,e,o),[r,...n]=t.filter((e=>e.coinType===o));if(void 0===r)throw new Error(`Coins array doesn't contain any coins of type ${o}`);const a=d.object(r.coinObjectId);return n.length&&d.mergeCoins(a,n.map((e=>d.object(e.coinObjectId)))),d.splitCoins(a,[d.pure(s)])}})(),[p]=d.moveCall({target:`${u}::state::verified_asset`,arguments:[d.object(this.tokenBridgeObjectId)],typeArguments:[o]}),g=await this.getPackageId(),[y]=d.moveCall({target:`${g}::transfer::transfer_tokens_with_relay`,arguments:[d.object(this.tokenBridgeRelayerObjectId),f,p,d.pure.u64(a??0n),d.pure.u16((0,n.a8)(t.chain)),d.pure.address(n.u.encode(t.address.toUint8Array(),!0)),d.pure.u32(123)],typeArguments:[o]}),[m]=d.moveCall({target:`${u}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[d.object(this.tokenBridgeObjectId),y],typeArguments:[o]});d.moveCall({target:`${c}::publish_message::publish_message`,arguments:[d.object(this.coreBridgeObjectId),h,m,d.object(tt)]}),yield this.createUnsignedTx(d,"AutomaticTokenBridge.transfer")}async*redeem(e,t){const{coreBridge:r,tokenBridge:s}=await this.getPackageIds(),{address:a,chain:o}=t.payload.token,c=await Hr(this.connection,this.tokenBridgeObjectId,a.toUniversalAddress().toUint8Array(),(0,n.a8)(o));if(!c)throw new Error("Unable to fetch token coinType");const u=new qr,[d]=u.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[u.object(this.coreBridgeObjectId),u.pure((0,i.u)((0,n.bN)(t))),u.object(tt)]}),[l]=u.moveCall({target:`${s}::vaa::verify_only_once`,arguments:[u.object(this.tokenBridgeObjectId),d]}),[h]=u.moveCall({target:`${s}::complete_transfer_with_payload::authorize_transfer`,arguments:[u.object(this.tokenBridgeObjectId),l],typeArguments:[c]}),f=await this.getPackageId();u.moveCall({target:`${f}::redeem::complete_transfer`,arguments:[u.object(this.tokenBridgeRelayerObjectId),h],typeArguments:[c]}),yield this.createUnsignedTx(u,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,t){const r=(0,n.p)(t)?i.S.nativeTokenId(this.network,this.chain):t,s=await this.getTokenInfo(r.toString());if(null===s)throw new Error("Unsupported token for relay");const a=await this.getFields(),o=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(n.a5.encode("relayer_fees"))}});if(!o.data||!o.data.content)throw o.error?new Error("Failed to get relayer fees: "+JSON.stringify(o.error)):new Error("Unable to compute relayer fee");const{content:c}=o.data;if(!(0,i.b)(c)||!(0,i.k)(c.fields.id))throw new Error("Unable to compute relayer fee");const u=await this.connection.getDynamicFieldObject({parentId:c.fields.id.id,name:{type:"u16",value:(0,n.a8)(e)}});if(!u.data||!u.data.content)throw u.error?new Error("Failed to get relayer fees: "+JSON.stringify(o.error)):new Error("Unable to compute relayer fee");const{content:d}=u.data;if(!(0,i.b)(d))throw new Error("Unable to compute relayer fee");const l=await i.S.getDecimals(this.chain,this.connection,t.toString()),h=s.swap_rate,f=a.relayer_fee_precision,p=a.swap_rate_precision,g=d.fields.value;return 10n**BigInt(l)*BigInt(g)*BigInt(p)/(BigInt(h)*BigInt(f))}async maxSwapAmount(e){var t,r;const s=((0,n.p)(e)?i.S.nativeTokenId(this.network,this.chain):e).toString(),a=await this.connection.getCoinMetadata({coinType:s});if(!a)throw new Error("metadata is null");const o=await this.getPackageId(),c=new qr;c.moveCall({target:`${o}::redeem::calculate_max_swap_amount_in`,arguments:[c.object(this.tokenBridgeRelayerObjectId),c.pure(a.decimals)],typeArguments:[s]});const u=await this.connection.devInspectTransactionBlock({transactionBlock:c,sender:n.u.encode(new Uint8Array(32))});if(!u.results||0==u.results.length||null==(t=u.results[0])||!t.returnValues||1!==(null==(r=u.results[0])?void 0:r.returnValues.length))throw Error("swap rate not set");return n.cq.decode(new Uint8Array(u.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){var r,s;const a=((0,n.p)(e)?i.S.nativeTokenId(this.network,this.chain):e).toString(),o=await this.connection.getCoinMetadata({coinType:a});if(!o)throw new Error("metadata is null");const c=await this.getPackageId(),u=new qr;u.moveCall({target:`${c}::redeem::calculate_native_swap_amount_out`,arguments:[u.object(this.tokenBridgeRelayerObjectId),u.pure(t),u.pure(o.decimals)],typeArguments:[a]});const d=await this.connection.devInspectTransactionBlock({transactionBlock:u,sender:n.u.encode(new Uint8Array(32))});if(!d.results||0==d.results.length||null==(r=d.results[0])||!r.returnValues||1!==(null==(s=d.results[0])?void 0:s.returnValues.length))throw Error("swap rate not set");return n.cq.decode(new Uint8Array(d.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map((e=>{const{address:t,module:r,name:i}=Xe(e.objectType).typeParams[0];return new n.Q([t,r,i].join(n.cX))}))}async isRegisteredToken(e){const t=new n.Q((0,n.p)(e)?i.S.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return null!==await this.getTokenInfo(t)}catch(r){console.error(r)}return!1}async getTokenInfo(e){var t;const r=await this.getFields(),s=new n.Q(r.registered_tokens.type).getPackageId(),a=r.registered_tokens.fields.id.id,o=new n.Q(e),c=(0,i.e)(n.O,o.unwrap())?n.O:o.getCoinType();try{const e=await this.connection.getDynamicFieldObject({parentId:a,name:{type:`${s}::registered_tokens::Key<${c}>`,value:{dummy_field:!1}}});if(e.error)throw new Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw new Error("Failed to get token info: "+JSON.stringify(e));const{content:t}=e.data;return(0,i.b)(t)&&(0,i.b)(t.fields.value)?t.fields.value.fields:null}catch(u){if(-32e3===(null==u?void 0:u.code)&&null!=(t=u.message)&&t.includes("RPC Error"))return console.error(u),null;throw u}}async getFields(){if(!this.fields){const e=await(0,i.g)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw new Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){const e=await this.getFields();return new n.Q(e.registered_tokens.type).getPackageId()}async getPackageIds(){const[e,t]=await Promise.all([(0,i.h)(this.connection,this.coreBridgeObjectId),(0,i.h)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new o(e,this.network,this.chain,t,r)}}(0,n.bS)("Sui","TokenBridge",Xr),(0,n.bS)("Sui","AutomaticTokenBridge",Zr)},1364:(e,t,r)=>{r.r(t),r.d(t,{SuiWormholeCore:()=>o});var n=r(7718),i=r(3016),s=Object.defineProperty,a=(e,t,r)=>((e,t,r)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class o{constructor(e,t,r,i){a(this,"network"),a(this,"chain"),a(this,"provider"),a(this,"contracts"),a(this,"chainId"),a(this,"coreBridgePackageId"),this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=(0,n.a8)(t);const s=i.coreBridge;if(!s)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=s}getGuardianSet(e){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,n]=await i.S.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} !== ${r}`);return new o(r,n,e,s.contracts)}async*verifyMessage(e,t){throw new Error("Method not implemented.")}async*publishMessage(e,t){throw new Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map((e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain})))}async getGuardianSetIndex(){throw new Error("Method not implemented.")}async parseMessages(e){var t;const r=null==(t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events)?void 0:t.filter((e=>e.type.endsWith("WormholeMessage")));if(!r||0==r.length)throw new Error("WormholeMessage not found");return r.map((e=>{const t=e.parsedJson;return(0,n.cM)("Uint8Array",{emitterChain:this.chain,emitterAddress:new n.Q(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})}))}}(0,n.bS)("Sui","WormholeCore",o)}}]);
//# sourceMappingURL=590.f19bc740.chunk.js.map