"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[606],{1606:(e,t,r)=>{r.r(t),r.d(t,{AptosWormholeCore:()=>a});var n=r(7718),s=r(3057),o=Object.defineProperty,i=(e,t,r)=>((e,t,r)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class a{constructor(e,t,r,s){i(this,"network"),i(this,"chain"),i(this,"connection"),i(this,"contracts"),i(this,"chainId"),i(this,"coreBridge"),this.network=e,this.chain=t,this.connection=r,this.contracts=s,this.chainId=(0,n.a8)(t);const o=s.coreBridge;if(!o)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=o}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,n]=await s.A.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error(`Network mismatch: ${o.network} !== ${r}`);return new a(r,n,e,o.contracts)}async*publishMessage(e,t){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map((e=>({chain:e.emitterChain,emitter:e.emitterAddress,sequence:e.sequence})))}async parseMessages(e){const t=await this.connection.getTransactionByHash(e);if("user_transaction"!==t.type)throw new Error(`${e} is not a user_transaction`);const r=t.events.filter((e=>e.type.endsWith("WormholeMessage")));if(!r||0===r.length)throw new Error(`WormholeMessage not found for ${e}`);return r.map((e=>{const t=e.data,r=new n.ca(BigInt(t.sender).toString(16).padStart(64,"0"));return(0,n.cM)("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:r,sequence:BigInt(t.sequence),timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:Number(t.nonce),signatures:[],payload:n.u.decode(t.payload)})}))}}(0,n.bS)("Aptos","WormholeCore",a)}}]);
//# sourceMappingURL=606.d0acf3f7.chunk.js.map