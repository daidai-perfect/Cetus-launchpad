"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[453],{2453:(t,e,r)=>{r.r(e),r.d(e,{EvmPorticoBridge:()=>d});var i=r(7718),n=(r(6592),Object.defineProperty),o=(t,e,r)=>((t,e,r)=>e in t?n(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r)(t,"symbol"!=typeof e?e+"":e,r);const s=new i.bF(["function start((bytes32,address,address,address,address,address,uint256,uint256,uint256,uint256)) returns (address,uint16,uint64)","function receiveMessageAndSwap(bytes)"]),a=new i.bF(["function quoteExactInputSingle((address,address,uint256,uint24,uint160)) public view returns (uint256,uint160,uint32,uint256)"]),c=100;class h{static async createOrder(t,e,r,n,o,s,a,h){var d,w;try{const{minAmountStart:d,minAmountFinish:w}=a.swapAmounts,u=(0,i.bG)(r),[p,m]=(0,i.bH)(t,e,n),[l,g]=(0,i.bH)(t,r.chain,s),f=(0,i.bG)(m),b=(0,i.bG)(g),v=i.bI.get(t,e).portico,E=i.bI.get(t,r.chain).portico,y=i.aj.get(t,e),A=i.aj.get(t,r.chain),k={startingChainId:Number(y),startingToken:f.toLowerCase(),destinationChainId:Number(A),destinationToken:b.toLowerCase(),destinationAddress:u,porticoAddress:v,destinationPorticoAddress:E,startingTokenAmount:o.toString(),minAmountStart:d.toString(),minAmountEnd:w.toString(),bridgeNonce:h,relayerFee:a.relayerFee.toString(),feeTierStart:c,feeTierEnd:c,shouldWrapNative:p,shouldUnwrapNative:l},T=await i.h.post("https://thermae.fly.dev/api/order/create",k);return this.validateCreateOrderResponse(T.data,k),T.data}catch(u){if(i.h.isAxiosError(u)){const t=`${null==(d=u.response)?void 0:d.statusText}: ${null==(w=u.response)?void 0:w.data.message}`;throw new Error(`Could not create order: ${t},`)}throw u}}static async quoteRelayer(t,e,r){var n;if((0,i.p)(e)||(0,i.p)(r))throw new Error("how did you get here tho?");const o=i.u.encode(e.toUniversalAddress().toUint8Array(),!1),s=i.u.encode(r.toUniversalAddress().toUint8Array(),!1),a={targetChain:(0,i.a8)(t),sourceToken:o,targetToken:s};try{const t=await i.h.post("https://gfx.relayers.xlabs.xyz/api/v1/swap/quote",a);return BigInt(t.data.fee)}catch(c){throw i.h.isAxiosError(c)?new Error(`Error getting relayer fee: ${null==(n=c.response)?void 0:n.statusText}`):c}}}o(h,"validateCreateOrderResponse",((t,e)=>{if(!(0,i.bJ)(e.porticoAddress||"",t.transactionTarget))throw new Error("portico address mismatch");const r=s.decodeFunctionData("start",t.transactionData);if(1!==r.length||10!==r[0].length)throw new Error("decoded length mismatch");const n=i.u.decode(r[0][0]);if(32!==n.length)throw new Error("flag set length mismatch");const{recipientChain:o,feeTierStart:a,feeTierFinish:c,flags:h}=i.bK.deserializeFlagSet(n),{shouldWrapNative:d,shouldUnwrapNative:w}=h,[u,p]=(0,i.t)("Evm",BigInt(e.destinationChainId));if(o!==(0,i.a8)(p))throw new Error("recipient chain mismatch");if(a!==e.feeTierStart)throw new Error("fee tier start mismatch");if(c!==e.feeTierEnd)throw new Error("fee tier end mismatch");if(!!d!==e.shouldWrapNative)throw new Error("should wrap native mismatch");if(!!w!==e.shouldUnwrapNative)throw new Error("should unwrap native mismatch");const m=r[0][1];if(!(0,i.bJ)(m,e.startingToken))throw new Error("start token address mismatch");const l=r[0][3];if(!(0,i.bJ)(l,e.destinationToken))throw new Error("final token address mismatch");const g=r[0][4];if(!(0,i.bJ)(g,e.destinationAddress))throw new Error("recipient address mismatch");const f=r[0][5];if(!(0,i.bJ)(f,e.destinationPorticoAddress||""))throw new Error("destination portico address mismatch");if(r[0][6].toString()!==e.startingTokenAmount)throw new Error("amount mismatch");if(r[0][7].toString()!==e.minAmountStart)throw new Error("min amount start mismatch");if(r[0][8].toString()!==e.minAmountEnd)throw new Error("min amount finish mismatch");if(r[0][9].toString()!==e.relayerFee)throw new Error("relayer fee mismatch")}));class d{constructor(t,e,r,n){if(o(this,"network"),o(this,"chain"),o(this,"provider"),o(this,"contracts"),o(this,"chainId"),o(this,"porticoAddress"),o(this,"uniswapAddress"),o(this,"porticoContract"),o(this,"uniswapContract"),o(this,"core"),this.network=t,this.chain=e,this.provider=r,this.contracts=n,!n.portico)throw new Error("Unsupported chain, no contract addresses for: "+e);this.core=new i.bL(t,e,r,n);const{portico:c,uniswapQuoterV2:h}=n.portico;this.porticoAddress=c,this.uniswapAddress=h,this.chainId=i.aj.get(t,e),this.porticoContract=new i.aA(this.porticoAddress,s.fragments,this.provider),this.uniswapContract=new i.aA(this.uniswapAddress,a.fragments,this.provider)}static async fromRpc(t,e){const[r,n]=await i.E.chainFromRpc(t),o=e[n];if(o.network!==r)throw new Error(`Network mismatch: ${o.network} != ${r}`);return new d(r,n,t,o.contracts)}async*transfer(t,e,r,n,o,a){const{minAmountStart:h,minAmountFinish:d}=a.swapAmounts;if(0n===h)throw new Error("Invalid min swap amount");if(0n===d)throw new Error("Invalid min swap amount");const w=new i.a(t).toString(),[u,p]=(0,i.bH)(this.network,this.chain,r),[m,l]=(0,i.bH)(this.network,e.chain,o),g=(0,i.bG)(p),f=(0,i.bG)(this.getTransferrableToken(g)),b=(0,i.bG)(e),v=(0,i.bG)(l),E=i.bI.get(this.network,e.chain).portico,y=(new Date).valueOf()%16,A=i.bK.serializeFlagSet({flags:{shouldWrapNative:u,shouldUnwrapNative:m},recipientChain:(0,i.a8)(e.chain),bridgeNonce:y,feeTierStart:c,feeTierFinish:c,padding:new Uint8Array(19)}),k=s.encodeFunctionData("start",[[A,g.toLowerCase(),f,v.toLowerCase(),b,E,n.toString(),h.toString(),d.toString(),a.relayerFee.toString()]]);u||(yield*this.approve(g,w,n,this.porticoAddress));const T=await this.core.getMessageFee(),S={to:this.porticoAddress,data:k,value:T+(u?n:0n)};yield this.createUnsignedTransaction((0,i.bM)(S,w),"PorticoBridge.Transfer")}async*redeem(t,e){const r=await this.porticoContract.getFunction("receiveMessageAndSwap").populateTransaction((0,i.bN)(e)),n=new i.a(t).toString();yield this.createUnsignedTransaction((0,i.bM)(r,n),"PorticoBridge.Redeem")}async quoteSwap(t,e,r){const[,n]=(0,i.bH)(this.network,this.chain,t),[,o]=(0,i.bH)(this.network,this.chain,e),s=(0,i.bG)(n),a=(0,i.bG)(o);return(0,i.bJ)(s,a)?r:(await this.uniswapContract.getFunction("quoteExactInputSingle").staticCall([s,a,r,c,0]))[0]}async quoteRelay(t,e){return await h.quoteRelayer(this.chain,t,e)}getTransferrableToken(t){var e;if("Ethereum"===this.chain)return i.l.tokenId("Ethereum",t);const r=(0,i.bO)(this.network,this.chain,t);if(!r)throw new Error("Unsupported source token: "+t);const n=null==(e=(0,i.bP)(this.network,this.chain,r.symbol))?void 0:e.find((t=>"Ethereum"===t.original));if(!n)throw new Error(`Unsupported symbol for chain ${r.symbol}: ${this.chain} `);return i.l.tokenId(n.chain,n.address)}async*approve(t,e,r,n){const o=i.E.getTokenImplementation(this.provider,t);if(await o.allowance(e,n)<r){const t=await o.approve.populateTransaction(n,r);yield this.createUnsignedTransaction((0,i.bM)(t,e),"PorticoBridge.Approve")}}createUnsignedTransaction(t,e){return new i.bQ((0,i.bR)(t,this.chainId),this.network,this.chain,e,!1)}}(0,i.bS)(i._,"PorticoBridge",d)}}]);
//# sourceMappingURL=453.414ea685.chunk.js.map