"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[720,163],{2720:(e,t,n)=>{n.r(t),n.d(t,{AlgorandTokenBridge:()=>p,TransferMethodSelector:()=>d});var s=n(8163),o=n(7718),r=n(9091),a=Object.defineProperty,i=(e,t,n)=>((e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);const d=o.da.fromSignature("portal_transfer(byte[])byte[]"),c=class e{constructor(e,t,n,r){if(i(this,"network"),i(this,"chain"),i(this,"connection"),i(this,"contracts"),i(this,"chainId"),i(this,"coreBridge"),i(this,"coreAppId"),i(this,"coreAppAddress"),i(this,"tokenBridgeAppId"),i(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=r,this.chainId=(0,o.a8)(t),!r.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const a=BigInt(r.coreBridge);if(this.coreAppId=a,this.coreAppAddress=(0,o.db)(a),this.coreBridge=new s.A(e,t,n,r),!r.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const d=BigInt(r.tokenBridge);this.tokenBridgeAppId=d,this.tokenBridgeAddress=(0,o.db)(d)}static async fromRpc(t,n){const[s,o]=await r.A.chainFromRpc(t),a=n[o];if(a.network!==s)throw new Error(`Network mismatch: ${a.network} != ${s}`);return new e(s,o,t,a.contracts)}async isWrappedAsset(e){const t=new o.an(e).toInt();if(0===t)return!1;const n=await this.connection.getAssetByID(t).do(),s=o.dc.from_obj_for_encoding(n).params.creator,r=await this.connection.accountInformation(s).exclude("all").do(),a=o.dd.from_obj_for_encoding(r);return(null==a?void 0:a.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(e){const t=new o.an(e).toInt(),n=await this.connection.getAssetByID(t).do(),r=o.dc.from_obj_for_encoding(n),a=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,r.params.creator);if(a.length<94)throw new Error("Invalid local state data");const i=a.slice(92,94);return{chain:(0,o.c9)(o.cq.decode(i)),address:new o.ca(a.slice(60,92))}}async getTokenUniversalAddress(e){return new o.an(e).toUniversalAddress()}async getTokenNativeAddress(e,t){return new o.an(t).toNative()}async getWrappedAsset(e){if((0,o.p)(e.address))throw new Error("native asset cannot be a wrapped asset");const t=s.S.forWrappedAsset(this.tokenBridgeAppId,e),n=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,t.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return(0,o.cf)(this.chain,o.cq.decode(n.slice(0,8)).toString())}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedNative(){return(0,o.cf)(this.chain,"0")}async isTransferCompleted(e){const t=s.S.forMessageId(this.tokenBridgeAppId,{sequence:e.sequence,chain:e.emitterChain,emitter:e.emitterAddress});try{return await s.S.checkBitsSet(this.connection,this.tokenBridgeAppId,t.address(),e.sequence)}catch{}return!1}async*createAttestation(t,n){if(!n)throw new Error("Payer required to create attestation");const r=new o.an(n).toString(),a=new o.an(t).toInt(),i=[],d=await this.connection.getTransactionParams().do(),c=s.S.forEmitter(this.coreAppId,new o.an(this.tokenBridgeAddress).toUint8Array()),{accounts:[p],txs:g}=await s.A.maybeCreateStorageTx(this.connection,r,this.coreAppId,c,d);i.push(...g);let h,f="";if(0!==a){const e=await this.connection.getAssetByID(a).do(),t=o.dc.from_obj_for_encoding(e),n=await this.connection.accountInformation(t.params.creator).do();if(h=o.dd.from_obj_for_encoding(n),h.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const u=s.S.forNativeAsset(this.tokenBridgeAppId,BigInt(a)),l=await s.A.maybeCreateStorageTx(this.connection,r,this.tokenBridgeAppId,u);f=l.accounts[0],i.push(...l.txs);const A=(0,o.de)({from:r,appIndex:(0,o.df)(this.tokenBridgeAppId),onComplete:o.dg.NoOpOC,appArgs:[e.noop],suggestedParams:d});i.push({tx:A});const m=await this.coreBridge.getMessageFee();if(m>BigInt(0)){const e=(0,o.dh)({from:r,suggestedParams:d,to:this.tokenBridgeAddress,amount:m});i.push({tx:e})}let I=[p,f,this.coreAppAddress];h&&I.push(h.address);let w=(0,o.de)({appArgs:[e.attestToken,o.cq.toBytes(a,8)],accounts:I,appIndex:(0,o.df)(this.tokenBridgeAppId),foreignApps:[(0,o.df)(this.coreAppId)],foreignAssets:[a],from:r,onComplete:o.dg.NoOpOC,suggestedParams:d});m>BigInt(0)?w.fee*=3:w.fee*=2,i.push({tx:w});for(const e of i)yield this.createUnsignedTx(e,"TokenBridge.createAttestation",!0)}async*submitAttestation(t,n,r){if(!n)throw new Error("Sender required to submit attestation");r||(r=await this.connection.getTransactionParams().do());const a=n.toString(),i=s.S.forWrappedAsset(this.tokenBridgeAppId,t.payload.token).address(),d=[],c=[],p=await s.S.decodeLocalState(this.connection,this.tokenBridgeAppId,i);p.length>8&&c.push(new o.an(p.slice(0,8)).toInt()),d.push({tx:(0,o.dh)({from:a,to:i,amount:1e5,suggestedParams:r})});let g=new Uint8Array(1);g[0]=1,d.push({tx:(0,o.de)({appArgs:[e.noop,g],appIndex:(0,o.df)(this.tokenBridgeAppId),from:a,onComplete:o.dg.NoOpOC,suggestedParams:r})}),g=new Uint8Array(1),g[0]=2,d.push({tx:(0,o.de)({appArgs:[e.noop,g],appIndex:(0,o.df)(this.tokenBridgeAppId),from:a,onComplete:o.dg.NoOpOC,suggestedParams:r})}),d.push({tx:(0,o.de)({accounts:[],appArgs:[e.receiveAttest,(0,o.bN)(t)],appIndex:(0,o.df)(this.tokenBridgeAppId),foreignAssets:c,from:a,onComplete:o.dg.NoOpOC,suggestedParams:r})}),d[d.length-1].tx.fee=2*d[d.length-1].tx.fee;for(const e of d)yield this.createUnsignedTx(e,"TokenBridge.submitAttestation",!0)}async*transfer(t,n,r,a,i){const d=t.toString(),c=(0,o.p)(r)?0:new o.an(r).toInt(),p=a,g=(0,o.a8)(n.chain),h=n.address.toUniversalAddress().toUint8Array(),f=await this.connection.getTransactionParams().do(),u=BigInt(0),l=s.S.fromData({appId:this.coreAppId,appAddress:(0,o.di)(this.coreAppAddress).publicKey,idx:BigInt(0),address:(0,o.di)(this.tokenBridgeAddress).publicKey}),A=[],{accounts:[m],txs:I}=await s.A.maybeCreateStorageTx(this.connection,d,this.coreAppId,l,f);A.push(...I);let w,y="",B=!1;if(0!==c){const e=await this.connection.getAssetByID(c).do();y=o.dc.from_obj_for_encoding(e).params.creator;const t=await this.connection.accountInformation(y).do();w=o.dd.from_obj_for_encoding(t),B=w.authAddr===this.tokenBridgeAddress.toString()}const x=await this.coreBridge.getMessageFee();if(x>0&&A.push({tx:(0,o.dh)({from:d,to:this.tokenBridgeAddress,amount:x,suggestedParams:f})}),!B){const e=s.S.forNativeAsset(this.tokenBridgeAppId,BigInt(c)),{accounts:[t],txs:n}=await s.A.maybeCreateStorageTx(this.connection,d,this.tokenBridgeAppId,e,f);y=t,n.push(...n)}if(0!==c&&!await e.isOptedInToAsset(this.connection,y,c)){const t=(0,o.dh)({from:d,to:y,amount:1e5,suggestedParams:f});let n=(0,o.de)({from:d,appIndex:(0,o.df)(this.tokenBridgeAppId),onComplete:o.dg.NoOpOC,appArgs:[e.optIn,(0,o.dj)(c,8)],foreignAssets:[c],accounts:[y],suggestedParams:f});n.fee*=2,A.unshift({tx:t},{tx:n})}const b=(0,o.de)({from:d,appIndex:(0,o.df)(this.tokenBridgeAppId),onComplete:o.dg.NoOpOC,appArgs:[e.noop],suggestedParams:f});A.push({tx:b});let k=[];if(0===c){const e=(0,o.dh)({from:d,to:y,amount:p,suggestedParams:f});A.push({tx:e}),k=[m,y,y]}else{const e=(0,o.dk)({from:d,to:y,amount:p,assetIndex:c,suggestedParams:f});A.push({tx:e}),k=null!=w&&w.address?[m,y,w.address]:[m,y]}const _=[e.sendTransfer,o.cq.toBytes(c,8),o.cq.toBytes(p,8),h,o.cq.toBytes(g,8),o.cq.toBytes(u,8)];i&&_.push(i);const S=(0,o.de)({from:d,appIndex:(0,o.df)(this.tokenBridgeAppId),onComplete:o.dg.NoOpOC,appArgs:_,foreignApps:[(0,o.df)(this.coreAppId)],foreignAssets:[c],accounts:k,suggestedParams:f});S.fee*=2,A.push({tx:S});for(const e of A)yield this.createUnsignedTx(e,"TokenBridge.transfer",!0)}redeem(t,n){try{var r=this;let a=arguments.length>3?arguments[3]:void 0;return async function*(){a||(a=await r.connection.getTransactionParams().do());const i=new o.an(t).toString(),{accounts:c,txs:p}=await s.A.submitVAAHeader(r.connection,r.coreAppId,r.tokenBridgeAppId,n,i);let g,h="",f=[],u=0;if(n.payload.token.chain!==r.chain){g=s.S.forWrappedAsset(r.tokenBridgeAppId,n.payload.token),h=g.address();const e=await s.S.decodeLocalState(r.connection,r.tokenBridgeAppId,h);u=new o.an(e.slice(0,8)).toInt()}else{const e=new o.an(n.payload.token.address).toBigInt();g=s.S.forNativeAsset(r.tokenBridgeAppId,e),h=g.address(),u=(0,o.df)(e)}c.push(h);let l=0,A="";if("TransferWithPayload"===n.payloadName?(l=new o.an(n.payload.to.address).toInt(),A=(0,o.db)(l)):A=new o.an(n.payload.to.address.toUint8Array()).toString(),c.push(A),0!==u&&(f.push(u),!await e.isOptedInToAsset(r.connection,A,u))){if(i!=A)throw new Error("Cannot ASA optin for somebody else (asset "+u.toString()+")");p.unshift({tx:(0,o.dk)({amount:0,assetIndex:u,from:i,suggestedParams:a,to:i})})}const m={accounts:c,appArgs:[e.completeTransfer,(0,o.bN)(n)],appIndex:(0,o.df)(r.tokenBridgeAppId),foreignAssets:f,from:i,onComplete:o.dg.NoOpOC,suggestedParams:a};p.push({tx:(0,o.de)(m)}),p[p.length-1].tx.fee=p[p.length-1].tx.fee*("Transfer"===n.payloadName&&void 0!==n.payload.fee&&0n===n.payload.fee?2:3),"TransferWithPayload"===n.payloadName&&(p[p.length-1].tx.appForeignApps=[l],p.push({tx:(0,o.de)({appArgs:[d.getSelector(),d.args[0].type.encode((0,o.bN)(n))],appIndex:l,foreignAssets:f,from:i,onComplete:o.dg.NoOpOC,suggestedParams:a})}));for(const e of p)yield r.createUnsignedTx(e,"TokenBridge.redeem",!0)}()}catch(t){return Promise.reject(t)}}static async isOptedInToAsset(e,t,n){var s;try{const r=await e.accountAssetInformation(t,n).do();return((null==(s=o.dl.from_obj_for_encoding(r).assetHolding)?void 0:s.amount)??0)>0}catch{}return!1}createUnsignedTx(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return new s.a(e,this.network,this.chain,t,n)}};i(c,"sendTransfer",o.a5.encode("sendTransfer")),i(c,"attestToken",o.a5.encode("attestToken")),i(c,"noop",o.a5.encode("nop")),i(c,"optIn",o.a5.encode("optin")),i(c,"completeTransfer",o.a5.encode("completeTransfer")),i(c,"receiveAttest",o.a5.encode("receiveAttest"));let p=c;(0,o.bS)(o.ak,"TokenBridge",p)},8163:(e,t,n)=>{n.r(t),n.d(t,{A:()=>u,S:()=>h,a:()=>i,i:()=>l});var s=n(7718),o=n(9091),r=Object.defineProperty,a=(e,t,n)=>((e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class i{constructor(e,t,n,s){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];a(this,"transaction"),a(this,"network"),a(this,"chain"),a(this,"description"),a(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=o}}const d=1002e3,c=1016,p=15240,g={_limit:127,encodingLength:e=>{let t=0;for(;e>=128;t++)e>>=7;return t+1},encode:(e,t,n)=>{if("bigint"==typeof e&&(e=(0,s.df)(e)),e<0)throw new RangeError("value must be unsigned");const o=g.encodingLength(e);if(n=n||0,(t=t||new ArrayBuffer(o)).byteLength<n+o)throw new RangeError("the buffer is too small to encode the number at the offset");const r=new Uint8Array(t,n);let a=0;for(;g._limit<e;)r[a++]=e&g._limit|128,e>>=7;return r[a]=Number(e),r},decode:function(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=0,o=0;do{if(t=e[n+o],void 0===t)throw new RangeError("offset out of range");s+=(t&g._limit)<<7*o,o++}while(128<=t);return s}},h={forMessageId:(e,t)=>{const n=(0,s.di)((0,s.db)(e)).publicKey,o=t.emitter.toUniversalAddress().toUint8Array(),r=s.cq.toBytes(BigInt((0,s.a8)(t.chain)),2),a=s.a5.concat(r,o);return h.fromData({appId:e,appAddress:n,idx:t.sequence/BigInt(p),address:a})},forWrappedAsset:(e,t)=>{if((0,s.p)(t.address))throw new Error("native asset cannot be a wrapped asset");const n=(0,s.di)((0,s.db)(e)).publicKey;return h.fromData({appId:e,appAddress:n,idx:BigInt((0,s.a8)(t.chain)),address:t.address.toUniversalAddress().toUint8Array()})},forNativeAsset:(e,t)=>{const n=(0,s.di)((0,s.db)(e)).publicKey;return h.fromData({appId:e,appAddress:n,idx:t,address:s.a5.encode("native")})},forGuardianSet:(e,t)=>{const n=(0,s.di)((0,s.db)(e)).publicKey;return h.fromData({appId:e,appAddress:n,idx:BigInt(t),address:s.a5.encode("guardian")})},forEmitter:(e,t)=>{const n=(0,s.di)((0,s.db)(e)).publicKey;return h.fromData({appId:e,appAddress:n,idx:0n,address:t})},_encode:e=>"bigint"==typeof e?[s.u.encode(g.encode(e))]:[s.u.encode(g.encode(e.length)),s.u.encode(e)],fromData:e=>{const t=["0620010181",...h._encode(e.idx),"4880",...h._encode(e.address),"483110810612443119221244311881",...h._encode(e.appId),"1244312080",...h._encode(e.appAddress),"124431018100124431093203124431153203124422"],n=s.u.decode(t.join(""));return new s.dm(n)},decodeLocalState:async(e,t,n)=>{let o;try{const r=await e.accountApplicationInformation(n,(0,s.df)(t)).do();o=s.dn.from_obj_for_encoding(r).appLocalState}catch{return new Uint8Array}const r=s.N.encode("meta");let a=new Map;for(const d of o.keyValue){if(d.key===r)continue;const e=s.N.decode(d.key)[0],t=s.N.decode(d.value.bytes);a.set(e,t)}const i=[];for(let s=0;s<15;s++)a.has(s)&&i.push(a.get(s));return s.a5.concat(...i)},checkBitsSet:async(e,t,n,o)=>{let r,a=!1;const i=await e.accountInformation(n).do(),d=s.dd.from_obj_for_encoding(i).appsLocalState;if(d&&d.forEach((e=>{BigInt(e.id)===t&&(r=e.keyValue)})),0===(null==r?void 0:r.length))return a;const g=BigInt(p),h=BigInt(8),f=o/g*g,u=(0,s.df)(o-f),l=Math.floor(u/c),A=Math.floor((u-l*c)/8),m=s.N.encode(s.cq.toBytes(l,1));return null==r||r.forEach((e=>{if(e.key!==m);else{const t=s.Z.Buffer.from(e.value.bytes,"base64"),n=1<<(0,s.df)(o%h);a=0!=(t[A]&n)}})),a},storageAccountExists:async(e,t,n)=>{try{const o=await e.accountApplicationInformation(t,(0,s.df)(n)).do();return Object.keys(o).length>0}catch{}return!1}},f=class e{constructor(e,t,n,o){if(a(this,"network"),a(this,"chain"),a(this,"connection"),a(this,"contracts"),a(this,"chainId"),a(this,"coreAppId"),a(this,"coreAppAddress"),a(this,"tokenBridgeAppId"),a(this,"tokenBridgeAppAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=o,this.chainId=(0,s.a8)(t),!o.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=(0,s.db)(r),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const i=BigInt(o.tokenBridge);this.tokenBridgeAppId=i,this.tokenBridgeAppAddress=(0,s.db)(i)}getGuardianSet(e){throw new Error("Method not implemented.")}async*verifyMessage(t,n,o){const r=new s.an(t).toString(),a=await e.submitVAAHeader(this.connection,this.coreAppId,o??this.coreAppId,n,r);for(const e of a.txs)yield this.createUnsignedTx(e,"Core.verifyMessage")}static async fromRpc(t,n){const[s,r]=await o.A.chainFromRpc(t),a=n[r];if(a.network!==s)throw new Error(`Network mismatch: ${a.network} !== ${s}`);return new e(s,r,t,a.contracts)}async*publishMessage(t,n){const o=new s.an(t),r=o.toString(),a=await this.connection.getTransactionParams().do(),i=h.forEmitter(this.coreAppId,o.toUint8Array()),{accounts:d,txs:c}=await e.maybeCreateStorageTx(this.connection,r,this.coreAppId,i,a);for(const e of c)yield this.createUnsignedTx(e,"Core.publishMessage",!0);const p=(0,s.de)({from:r,appIndex:(0,s.df)(this.coreAppId),appArgs:[e.publishMessage,n,s.cq.toBytes(0n,8)],accounts:d,onComplete:s.dg.NoOpOC,suggestedParams:a});yield this.createUnsignedTx({tx:p},"Core.publishMessage",!0)}async getMessageFee(){var t;const n=await this.connection.getApplicationByID((0,s.df)(this.coreAppId)).do(),o=null==(t=s.dp.from_obj_for_encoding(n).params.globalState)?void 0:t.find((t=>t.key===e.feeKey));return o?BigInt(o.value.uint):0n}async getGuardianSetIndex(){throw new Error("Not implemented")}async parseTransaction(e){const t=await this.connection.pendingTransactionInformation(e).do(),n=s.dq.from_obj_for_encoding(t);return this.parseTx(n).map((e=>({chain:e.emitterChain,emitter:e.emitterAddress,sequence:e.sequence})))}async parseMessages(e){const t=await this.connection.pendingTransactionInformation(e).do(),n=s.dq.from_obj_for_encoding(t);return this.parseTx(n)}parseTx(t){const n=[];if(t.innerTxns&&t.innerTxns.length>0&&n.push(...t.innerTxns.flatMap((e=>this.parseTx(e)))),BigInt(t.txn.txn.apid??0)!==this.coreAppId||!t.logs||0===t.logs.length)return n;const o=t.txn.txn.apaa??[];if(3!==o.length||!s.a5.equals(new Uint8Array(o[0]),e.publishMessage))return n;const r=s.cq.decode(t.logs[0]),a=new s.an(t.txn.txn.snd).toUniversalAddress(),i=new Uint8Array(o[1]),d=s.cq.decode(o[2]);return n.push((0,s.cM)("Uint8Array",{emitterChain:this.chain,emitterAddress:a,sequence:r,guardianSet:0,timestamp:0,consistencyLevel:0,nonce:Number(d),payload:i,signatures:[]})),n}static async maybeCreateStorageTx(e,t,n,o,r){const a=(0,s.db)(n),i=o.address(),c=[];if(await h.storageAccountExists(e,i,n))return{accounts:[i],txs:c};r=r??await e.getTransactionParams().do();const p=(0,s.dh)({from:t,to:i,amount:d,suggestedParams:r});p.fee=2*p.fee,c.push({tx:p});const g=(0,s.dr)({from:i,appIndex:(0,s.df)(n),rekeyTo:a,suggestedParams:r});return g.fee=0,c.push({tx:g,signer:{address:o.address(),signTxn:e=>Promise.resolve((0,s.ds)(e,o).blob)}}),{accounts:[i],txs:c}}static async submitVAAHeader(t,n,o,r,a,i){i=i??await t.getTransactionParams().do();let d=[];const c=h.forMessageId(o,{chain:r.emitterChain,sequence:r.sequence,emitter:r.emitterAddress}),{accounts:p,txs:g}=await e.maybeCreateStorageTx(t,a,o,c,i);d.push(...g);const f=h.forGuardianSet(n,r.guardianSet),{accounts:[u],txs:l}=await e.maybeCreateStorageTx(t,a,n,f,i);d.push(...l);let A=[...p,u];const m=await h.decodeLocalState(t,n,u),I=(0,s.cc)(r.hash),w=r.signatures.length,y=Math.ceil(w/e.MAX_SIGS_PER_TXN),B=new s.dm(e.ALGO_VERIFY);for(let h=0;h<y;h++){const t=h*e.MAX_SIGS_PER_TXN,o=r.signatures.slice(t,t+e.MAX_SIGS_PER_TXN),a=20*o.length,c=new Uint8Array(a);for(let e=0;e<o.length;e++){const t=o[e],n=m.slice(20*t.guardianIndex+1,20*(t.guardianIndex+1)+1);c.set(n,20*e)}const p=(0,s.de)({appArgs:[e.verifySigs,s.a5.concat(...o.map((e=>s.a5.concat(new Uint8Array([e.guardianIndex]),e.signature.encode())))),c,I],accounts:A,appIndex:(0,s.df)(n),from:e.ALGO_VERIFY_HASH,onComplete:s.dg.NoOpOC,suggestedParams:i});p.fee=0,d.push({tx:p,signer:{address:B.address(),signTxn:e=>Promise.resolve((0,s.ds)(e,B).blob)}})}const x=(0,s.de)({appArgs:[e.verifyVaa,(0,s.bN)(r)],accounts:A,appIndex:(0,s.df)(n),from:a,onComplete:s.dg.NoOpOC,suggestedParams:i});return x.fee=x.fee*(2+y),d.push({tx:x}),{accounts:A,txs:d}}createUnsignedTx(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return new i(e,this.network,this.chain,t,n)}};a(f,"MAX_SIGS_PER_TXN",6),a(f,"ALGO_VERIFY_HASH","EZATROXX2HISIRZDRGXW4LRQ46Z6IUJYYIHU3PJGP7P5IQDPKVX42N767A"),a(f,"ALGO_VERIFY",new Uint8Array([6,32,4,1,0,32,20,38,1,0,49,32,50,3,18,68,49,1,35,18,68,49,16,129,6,18,68,54,26,1,54,26,3,54,26,2,136,0,3,68,34,67,53,2,53,1,53,0,40,53,240,40,53,241,52,0,21,53,5,35,53,3,35,53,4,52,3,52,5,12,65,0,68,52,1,52,0,52,3,129,65,8,34,88,23,52,0,52,3,34,8,36,88,52,0,52,3,129,33,8,36,88,7,0,53,241,53,240,52,2,52,4,37,88,52,240,52,241,80,2,87,12,20,18,68,52,3,129,66,8,53,3,52,4,37,8,53,4,66,255,180,34,137])),a(f,"feeKey",s.N.encode("MessageFee")),a(f,"verifyVaa",s.a5.encode("verifyVAA")),a(f,"verifySigs",s.a5.encode("verifySigs")),a(f,"publishMessage",s.a5.encode("publishMessage"));let u=f;(0,s.bS)("Algorand","WormholeCore",u);const l=Object.freeze(Object.defineProperty({__proto__:null,AlgorandWormholeCore:u,BITS_PER_BYTE:8,BITS_PER_KEY:c,MAX_BITS:p,MAX_BYTES:1905,MAX_BYTES_PER_KEY:127,MAX_KEYS:15,SEED_AMT:d,StorageLogicSig:h,varint:g},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=720.5bbad420.chunk.js.map