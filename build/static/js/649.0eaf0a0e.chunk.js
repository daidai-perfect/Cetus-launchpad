"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[649],{6649:(e,t,s)=>{s.r(t),s.d(t,{default:()=>w});var n,i,r=s(7718),a=Object.defineProperty,o=e=>{throw TypeError(e)},c=(e,t,s)=>((e,t,s)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s)(e,"symbol"!=typeof t?t+"":t,s),h=(e,t,s)=>t.has(e)||o("Cannot "+s),d=(e,t,s)=>(h(e,t,"read from private field"),s?s.call(e):t.get(e)),g=(e,t,s)=>t.has(e)?o("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),l=(e,t,s,n)=>(h(e,t,"write to private field"),n?n.call(e,s):t.set(e,s),s);const p=class e extends r.A{constructor(e){super(e.provider),c(this,"signer"),g(this,n),g(this,i),(0,r.d)(this,{signer:e}),l(this,n,null),l(this,i,0)}async getAddress(){return this.signer.getAddress()}connect(t){return new e(this.signer.connect(t))}async getNonce(e){if("pending"===e){null==d(this,n)&&l(this,n,super.getNonce("pending"));const e=d(this,i);return await d(this,n)+e}return super.getNonce(e)}increment(){var e,t,s,n;(e=this,t=i,{set _(n){l(e,t,n,s)},get _(){return d(e,t,n)}})._++}reset(){l(this,i,0),l(this,n,null)}async sendTransaction(e){const t=this.getNonce("pending");return this.increment(),(e=await this.signer.populateTransaction(e)).nonce=await t,await this.signer.sendTransaction(e)}signTransaction(e){return this.signer.signTransaction(e)}signMessage(e){return this.signer.signMessage(e)}signTypedData(e,t,s){return this.signer.signTypedData(e,t,s)}};n=new WeakMap,i=new WeakMap;let u=p;class m extends r.P{constructor(e,t,s,n){super(e,t,s),c(this,"opts"),this.opts=n}chain(){return this._chain}address(){return this._address}async sign(e){var t,s,n,i,r,a;const o=this.chain(),c=[];let h=500000n,d=100000000000n,g=1500000000n,l=100000000n;if(void 0===(null==(t=this.opts)?void 0:t.overrides)&&"Celo"!==o){const e=await this._signer.provider.getFeeData();d=e.gasPrice??d,g=e.maxFeePerGas??g,l=e.maxPriorityFeePerGas??l}void 0!==(null==(s=this.opts)?void 0:s.maxGasLimit)&&(h=h>(null==(n=this.opts)?void 0:n.maxGasLimit)?null==(i=this.opts)?void 0:i.maxGasLimit:h);const p="Oasis"===o?{gasLimit:h,gasPrice:d,type:0}:{gasLimit:h,maxFeePerGas:g,maxPriorityFeePerGas:l};for(const u of e){const{transaction:e,description:t}=u;null!=(r=this.opts)&&r.debug&&console.log(`Signing: ${t} for ${this.address()}`);const s={...e,...p,from:this.address(),nonce:await this._signer.getNonce(),...null==(a=this.opts)?void 0:a.overrides};c.push(await this._signer.signTransaction(s))}return c}}const w={Address:r.a,Platform:r.E,getSigner:async function(e,t,s){const n="string"==typeof t?new r.W(t,e):t,i=(null==s?void 0:s.chain)??(await r.E.chainFromRpc(e))[1],a=new u(n);if(null===a.provider)try{a.connect(e)}catch(o){console.error("Cannot connect to network for signer",o)}return new m(i,await n.getAddress(),a,s)},protocols:{WormholeCore:()=>Promise.resolve().then(s.bind(s,7718)).then((e=>e.e2)),TokenBridge:()=>s.e(592).then(s.bind(s,6592)),PorticoBridge:()=>Promise.all([s.e(592),s.e(453)]).then(s.bind(s,2453)),CircleBridge:()=>Promise.all([s.e(592),s.e(814)]).then(s.bind(s,1814))},getChain:(e,t,s)=>new r.b(t,new r.E(e,(0,r.c)(e,r._,{[t]:s})))}}}]);
//# sourceMappingURL=649.0eaf0a0e.chunk.js.map