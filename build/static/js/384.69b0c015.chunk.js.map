{"version":3,"file":"static/js/384.69b0c015.chunk.js","mappings":"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","sources":["../node_modules/@wormhole-foundation/wormhole-connect/lib/index-BLx-SiXw.mjs"],"sourcesContent":["var m = Object.defineProperty;\nvar w = (i, e, t) => e in i ? m(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;\nvar a = (i, e, t) => w(i, typeof e != \"symbol\" ? e + \"\" : e, t);\nimport { C as u } from \"./cosmwasm-OHcxD9uL.mjs\";\nimport { cM as g, ca as l, u as h, bS as p, a9 as f } from \"./index-OfNVdS9m.mjs\";\nclass c {\n  constructor(e, t, s, r) {\n    a(this, \"network\");\n    a(this, \"chain\");\n    a(this, \"rpc\");\n    a(this, \"contracts\");\n    a(this, \"coreAddress\");\n    this.network = e, this.chain = t, this.rpc = s, this.contracts = r;\n    const n = this.contracts.coreBridge;\n    if (!n)\n      throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);\n    this.coreAddress = n;\n  }\n  getGuardianSet(e) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getGuardianSetIndex() {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMessageFee() {\n    throw new Error(\"Method not implemented.\");\n  }\n  static async fromRpc(e, t) {\n    const [s, r] = await u.chainFromRpc(e), n = t[r];\n    if (n.network !== s)\n      throw new Error(`Network mismatch: ${n.network} != ${s}`);\n    return new c(s, r, e, n.contracts);\n  }\n  async *publishMessage(e, t, s, r) {\n    throw new Error(\"Method not implemented.\");\n  }\n  async *verifyMessage(e, t) {\n    throw new Error(\"Not implemented.\");\n  }\n  async parseTransaction(e) {\n    const t = await this.rpc.getTx(e);\n    if (!t)\n      throw new Error(\"No transaction found for txid: \" + e);\n    return [c.parseWormholeMessageId(this.chain, this.coreAddress, t)];\n  }\n  async parseMessages(e) {\n    const t = await this.rpc.getTx(e);\n    if (!t)\n      throw new Error(\"No transaction found for txid: \" + e);\n    return [c.parseWormholeMessage(this.chain, this.coreAddress, t)];\n  }\n  static parseWormholeMessage(e, t, s) {\n    const r = s.events.filter((o) => o.type === \"wasm\" && o.attributes[0].key === \"_contract_address\" && o.attributes[0].value === t);\n    if (r.length === 0)\n      throw new Error(\"No wormhole message found in tx\");\n    r.length > 1 && console.error(`Expected single message, found ${r.length}`);\n    const [n] = r, d = Object.fromEntries(n.attributes.map((o) => [o.key.split(\".\")[1], o.value]));\n    return g(\"Uint8Array\", {\n      emitterChain: e,\n      emitterAddress: new l(h.decode(d.sender)),\n      sequence: BigInt(d.sequence),\n      guardianSet: 0,\n      // TODO: need to implement guardian set idx\n      timestamp: Number(d.block_time),\n      consistencyLevel: 0,\n      nonce: Number(d.nonce),\n      signatures: [],\n      payload: h.decode(d.message)\n    });\n  }\n  static parseWormholeMessageId(e, t, s) {\n    const r = c.parseWormholeMessage(e, t, s);\n    return {\n      chain: r.emitterChain,\n      emitter: r.emitterAddress,\n      sequence: r.sequence\n    };\n  }\n}\np(f, \"WormholeCore\", c);\nexport {\n  c as CosmwasmWormholeCore\n};\n"],"names":["m","Object","defineProperty","a","i","e","t","w","enumerable","configurable","writable","value","c","constructor","s","r","this","network","chain","rpc","contracts","n","coreBridge","Error","coreAddress","getGuardianSet","getGuardianSetIndex","getMessageFee","static","u","async","getTx","parseWormholeMessageId","parseWormholeMessage","events","filter","o","type","attributes","key","length","console","error","d","fromEntries","map","split","g","emitterChain","emitterAddress","l","h","sender","sequence","BigInt","guardianSet","timestamp","Number","block_time","consistencyLevel","nonce","signatures","payload","message","emitter","p","f"],"sourceRoot":""}