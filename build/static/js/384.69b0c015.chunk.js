"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[384],{5384:(e,t,r)=>{r.r(t),r.d(t,{CosmwasmWormholeCore:()=>i});var s=r(3957),o=r(7718),n=Object.defineProperty,a=(e,t,r)=>((e,t,r)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class i{constructor(e,t,r,s){a(this,"network"),a(this,"chain"),a(this,"rpc"),a(this,"contracts"),a(this,"coreAddress"),this.network=e,this.chain=t,this.rpc=r,this.contracts=s;const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.coreAddress=o}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,o]=await s.C.chainFromRpc(e),n=t[o];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} != ${r}`);return new i(r,o,e,n.contracts)}async*publishMessage(e,t,r,s){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[i.parseWormholeMessageId(this.chain,this.coreAddress,t)]}async parseMessages(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[i.parseWormholeMessage(this.chain,this.coreAddress,t)]}static parseWormholeMessage(e,t,r){const s=r.events.filter((e=>"wasm"===e.type&&"_contract_address"===e.attributes[0].key&&e.attributes[0].value===t));if(0===s.length)throw new Error("No wormhole message found in tx");s.length>1&&console.error(`Expected single message, found ${s.length}`);const[n]=s,a=Object.fromEntries(n.attributes.map((e=>[e.key.split(".")[1],e.value])));return(0,o.cM)("Uint8Array",{emitterChain:e,emitterAddress:new o.ca(o.u.decode(a.sender)),sequence:BigInt(a.sequence),guardianSet:0,timestamp:Number(a.block_time),consistencyLevel:0,nonce:Number(a.nonce),signatures:[],payload:o.u.decode(a.message)})}static parseWormholeMessageId(e,t,r){const s=i.parseWormholeMessage(e,t,r);return{chain:s.emitterChain,emitter:s.emitterAddress,sequence:s.sequence}}}(0,o.bS)(o.a9,"WormholeCore",i)}}]);
//# sourceMappingURL=384.69b0c015.chunk.js.map