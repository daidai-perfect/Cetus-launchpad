"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[91],{9091:(n,t,o)=>{o.r(t),o.d(t,{A:()=>c,a:()=>u});var e=o(7718),a=Object.defineProperty,r=(n,t,o)=>((n,t,o)=>t in n?a(n,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):n[t]=o)(n,"symbol"!=typeof t?t+"":t,o);class s extends e.C{}const i=class n extends e.i{constructor(t,o){super(t,o??(0,e.k)(t,n._platform))}getRpc(n){if(n in this.config)return new e.al.Algodv2("",this.config[n].rpc);throw new Error("No configuration available for chain: "+n)}getChain(n){if(n in this.config)return new s(n,this);throw new Error("No configuration available for chain: "+n)}static nativeTokenId(t,o){if(!n.isSupportedChain(o))throw new Error(`invalid chain for Algorand: ${o}`);return e.l.chainAddress(o,e.am)}static isNativeTokenId(t,o,e){return!(!n.isSupportedChain(o)||e.chain!==o)&&this.nativeTokenId(t,o)==e}static isSupportedChain(t){return(0,e.o)(t)===n._platform}static async getDecimals(t,o,a){const r=(0,e.p)(a)?0:new e.an(a).toInt();if(0===r)return(0,e.q)(n._platform);const s=await o.getAssetByID(r).do(),i=e.al.modelsv2.Asset.from_obj_for_encoding(s);if(!i.params||!i.params.decimals)throw new Error("Could not fetch token details");return Number(i.params.decimals)}static async getBalance(n,t,o,a){const r=(0,e.p)(a)?0:new e.an(a).toInt();if(0===r){const n=await t.accountInformation(o).do(),a=e.al.modelsv2.Account.from_obj_for_encoding(n);return BigInt(a.amount)}const s=await t.accountAssetInformation(o,r).do(),i=e.al.modelsv2.AssetHolding.from_obj_for_encoding(s);return BigInt(i.amount)}static async getBalances(n,t,o,a){let r;if(a.includes("native")){const n=await t.accountInformation(o).do(),a=e.al.modelsv2.Account.from_obj_for_encoding(n);r=BigInt(a.amount)}return a.map((async n=>{if((0,e.p)(n))return{native:r};const a=new e.an(n).toInt(),s=await t.accountAssetInformation(o,a).do(),i=e.al.modelsv2.AssetHolding.from_obj_for_encoding(s);return BigInt(i.amount)})).reduce(((n,t)=>Object.assign(n,t)),{})}static async sendWait(n,t,o){const a=o.map(((n,t)=>e.al.decodeSignedTransaction(n))).map(((n,t)=>n.txn.txID())),{txId:r}=await t.sendRawTransaction(o).do();if(!r)throw new Error("Transaction(s) failed to send");const s=await e.al.waitForConfirmation(t,r,4);if(!e.al.modelsv2.PendingTransactionResponse.from_obj_for_encoding(s).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return a}static async getLatestBlock(n){const t=await n.status().do(),o=e.al.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!o.lastRound)throw new Error("Error getting status from node");return Number(o.lastRound)}static async getLatestFinalizedBlock(n){const t=await n.status().do(),o=e.al.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!o.lastRound)throw new Error("Error getting status from node");return Number(o.lastRound)}static chainFromChainId(t){const o=(0,e.t)(n._platform,t);if(void 0===o)throw new Error(`Unknown native chain id ${t}`);const[a,r]=o;return[a,r]}static async chainFromRpc(n){const t=await n.versionsCheck().do(),o=e.al.modelsv2.Version.from_obj_for_encoding(t);return this.chainFromChainId(o.genesisId)}};r(i,"_platform",e.ak);let c=i;class d{constructor(n,t,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];r(this,"_chain"),r(this,"_debug"),r(this,"_account"),this._chain=n,this._debug=a,this._account=(0,e.ao)(o)}chain(){return this._chain}address(){return this._account.addr}async sign(n){const t=[],o=n.map(((n,t)=>n.transaction.tx)),a=(0,e.ap)(o),r=n.map(((n,t)=>(n.transaction.tx=a[t],n)));for(const e of r){const{description:n,transaction:o}=e,{tx:a,signer:r}=o;this._debug&&(console.log(a._getDictForDisplay()),console.log(a.txID())),r?(this._debug&&console.log(`Signing: ${n} with signer ${r.address} for address ${this.address()}`),t.push(await r.signTxn(a))):(this._debug&&console.log(`Signing: ${n} without signer for address ${this.address()}`),t.push(a.signTxn(this._account.sk)))}return t}}const l={Address:e.an,Platform:c,getSigner:async function(n,t){const[o,e]=await c.chainFromRpc(n);return new d(e,n,t)},protocols:{WormholeCore:()=>o.e(163).then(o.bind(o,8163)).then((n=>n.i)),TokenBridge:()=>o.e(720).then(o.bind(o,2720))},getChain:(n,t,o)=>new s(t,new c(n,(0,e.c)(n,e.ak,{[t]:o})))},u=Object.freeze(Object.defineProperty({__proto__:null,default:l},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=91.70282db9.chunk.js.map