"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[365,384],{5384:(e,t,r)=>{r.r(t),r.d(t,{CosmwasmWormholeCore:()=>o});var n=r(3957),s=r(7718),a=Object.defineProperty,i=(e,t,r)=>((e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class o{constructor(e,t,r,n){i(this,"network"),i(this,"chain"),i(this,"rpc"),i(this,"contracts"),i(this,"coreAddress"),this.network=e,this.chain=t,this.rpc=r,this.contracts=n;const s=this.contracts.coreBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.coreAddress=s}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,s]=await n.C.chainFromRpc(e),a=t[s];if(a.network!==r)throw new Error(`Network mismatch: ${a.network} != ${r}`);return new o(r,s,e,a.contracts)}async*publishMessage(e,t,r,n){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[o.parseWormholeMessageId(this.chain,this.coreAddress,t)]}async parseMessages(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[o.parseWormholeMessage(this.chain,this.coreAddress,t)]}static parseWormholeMessage(e,t,r){const n=r.events.filter((e=>"wasm"===e.type&&"_contract_address"===e.attributes[0].key&&e.attributes[0].value===t));if(0===n.length)throw new Error("No wormhole message found in tx");n.length>1&&console.error(`Expected single message, found ${n.length}`);const[a]=n,i=Object.fromEntries(a.attributes.map((e=>[e.key.split(".")[1],e.value])));return(0,s.cM)("Uint8Array",{emitterChain:e,emitterAddress:new s.ca(s.u.decode(i.sender)),sequence:BigInt(i.sequence),guardianSet:0,timestamp:Number(i.block_time),consistencyLevel:0,nonce:Number(i.nonce),signatures:[],payload:s.u.decode(i.message)})}static parseWormholeMessageId(e,t,r){const n=o.parseWormholeMessage(e,t,r);return{chain:n.emitterChain,emitter:n.emitterAddress,sequence:n.sequence}}}(0,s.bS)(s.a9,"WormholeCore",o)},9365:(e,t,r)=>{r.r(t),r.d(t,{CosmwasmTokenBridge:()=>c});r(5384);var n=r(3957),s=r(2421),a=r(7718),i=Object.defineProperty,o=(e,t,r)=>((e,t,r)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class c{constructor(e,t,r,n){o(this,"network"),o(this,"chain"),o(this,"rpc"),o(this,"contracts"),o(this,"tokenBridge"),o(this,"translator"),this.network=e,this.chain=t,this.rpc=r,this.contracts=n;const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);if(this.tokenBridge=s,this.translator=this.contracts.translator,void 0!==this.translator&&""===this.translator)throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(e,t){const[r,s]=await n.C.chainFromRpc(e),a=t[s];if(a.network!==r)throw new Error(`Network mismatch: ${a.network} != ${r}`);return new c(r,s,e,t[s].contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{}return!1}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if(e.chain===this.chain)throw new Error(`Expected foreign chain, got ${e.chain}`);if((0,a.p)(e.address))throw new Error("Native asset cannot be a wrapped asset");const t=a.N.encode(e.address.toUniversalAddress().toUint8Array()),{address:r}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:(0,a.a8)(e.chain),address:t}});return(0,a.cf)(this.chain,r)}async getOriginalAsset(e){let t=new a.a3(e);"factory"===t.denomType&&(t=n.G.factoryToCw20(t));const r=await this.rpc.queryContractSmart(t.toString(),{wrapped_asset_info:{}}),s=(0,a.c9)(r.asset_chain),i=a.N.decode(r.asset_address);return{chain:s,address:new a.ca(new Uint8Array(i))}}async getTokenUniversalAddress(e){return new a.a3(e).toUniversalAddress()}async getTokenNativeAddress(e,t){return new a.a3(t).toNative()}async isTransferCompleted(e){const t=a.N.encode((0,a.bN)(e));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:t}})).is_redeemed}async*createAttestation(e,t){if(!t)throw new Error("Payer required to create attestation");const r=new a.a3(e).toString(),i=new a.a3(t).toString(),o=(0,a.p)(e)?{native_token:{denom:n.C.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:r}};yield this.createUnsignedTx({msgs:[(0,s.b)(i,this.tokenBridge,{create_asset_meta:{asset_info:o,nonce:0}})],fee:(0,s.c)(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(e,t){if(!t)throw new Error("Payer required to submit attestation");const r=new a.a3(t).toString();yield this.createUnsignedTx({msgs:[(0,s.b)(r,this.tokenBridge,{submit_vaa:{data:(0,a.bN)(e)}})],fee:(0,s.c)(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(e,t,r,i,o){const c=Math.round(1e5*Math.random()),d=(0,a.a8)(t.chain),h=a.N.encode(t.address.toUniversalAddress().toUint8Array()),m=n.C.getNativeDenom(this.network,this.chain),l=(0,a.p)(r);let w=l?m:r.toString();w.startsWith("factory")&&(w=n.G.factoryToCw20(new a.a3(w)).toString());const g=new a.a3(e).toString(),u=e=>{const t={asset:{amount:i.toString(),info:e},recipient_chain:d,recipient:h,fee:"0",nonce:c};return o?{initiate_transfer_with_payload:{...t,payload:a.N.encode(o)}}:{initiate_transfer:t}};if(l){const e=[(0,s.b)(g,this.tokenBridge,{deposit_tokens:{}},[{amount:i.toString(),denom:w}]),(0,s.b)(g,this.tokenBridge,u({native_token:{denom:w}}))];yield this.createUnsignedTx({msgs:e,fee:(0,s.c)(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const e=[(0,s.b)(g,w,{increase_allowance:{spender:this.tokenBridge,amount:i.toString(),expires:{never:{}}}}),(0,s.b)(g,this.tokenBridge,u({token:{contract_addr:w}}),[{amount:i.toString(),denom:w}])];yield this.createUnsignedTx({msgs:e,fee:(0,s.c)(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}redeem(e,t){try{var r=this;return async function*(){const n=a.N.encode((0,a.bN)(t)),i=new a.a3(e).toString(),o=r.translator&&new a.a3(r.translator).toUniversalAddress().equals(t.payload.to.address)?(0,s.b)(i,r.translator,{complete_transfer_and_convert:{vaa:n}}):(0,s.b)(i,r.tokenBridge,{submit_vaa:{data:n}});yield r.createUnsignedTx({msgs:[o],fee:(0,s.c)(r.network,r.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}()}catch(t){return Promise.reject(t)}}async parseTransactionDetails(e){throw new Error("Not implemented")}async getWrappedNative(){return(0,a.cf)(this.chain,n.C.getNativeDenom(this.network,this.chain))}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new s.C(e,this.network,this.chain,t,r)}}(0,a.bS)(a.a9,"TokenBridge",c)},2421:(e,t,r)=>{r.d(t,{C:()=>d,b:()=>c,c:()=>o});var n=r(3957),s=r(7718),a=Object.defineProperty,i=(e,t,r)=>((e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);function o(e,t){let r=s.d7.get(e,t);return r||(r="0.1"),n.O.calculateFee(1.5*s.d8,`${r}${n.C.getNativeDenom(e,t)}`)}function c(e,t,r,a){return{typeUrl:s.d9,value:n.P.MsgExecuteContract.fromPartial({sender:e,contract:t,msg:s.a5.encode(JSON.stringify(r)),funds:a})}}class d{constructor(e,t,r,n){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];i(this,"transaction"),i(this,"network"),i(this,"chain"),i(this,"description"),i(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=s}}}}]);
//# sourceMappingURL=365.579e7b5b.chunk.js.map