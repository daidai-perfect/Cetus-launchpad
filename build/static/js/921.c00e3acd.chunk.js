"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[921],{2921:(e,t,s)=>{s.r(t),s.d(t,{AptosTokenBridge:()=>c});var n=s(7718),r=s(3057),a=Object.defineProperty,i=(e,t,s)=>((e,t,s)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s)(e,"symbol"!=typeof t?t+"":t,s);class o{constructor(e,t,s,n){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];i(this,"transaction"),i(this,"network"),i(this,"chain"),i(this,"description"),i(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=s,this.description=n,this.parallelizable=r}}const d=[{name:"tokenBridgeAddress",...n.cN},{name:"chain",...(0,n.cO)()},{name:"domainSeparator",binary:"bytes",custom:n.a5.encode(n.r),omit:!0},{name:"tokenId",...n.cN},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}];class c{constructor(e,t,s,r){i(this,"network"),i(this,"chain"),i(this,"connection"),i(this,"contracts"),i(this,"chainId"),i(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=s,this.contracts=r,this.chainId=(0,n.a8)(t);const a=r.tokenBridge;if(!a)throw new Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){const[s,n]=await r.A.chainFromRpc(e),a=t[n];if(a.network!==s)throw new Error("Network mismatch "+a.network+" !== "+s);return new c(s,n,e,a.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){const t=e.toString().split(n.r);let s;if(s=(await this.connection.getAccountResource(t[0],`${this.tokenBridgeAddress}::state::OriginInfo`)).data,!s)throw n.c8;return{chain:(0,n.c9)(parseInt(s.token_chain.number)),address:new n.ca(s.token_address.external_address)}}async getTokenUniversalAddress(e){return new n.ca(n.u.encode((0,n.cQ)(e.toString()),!0))}async getTokenNativeAddress(e,t){const s=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!s)throw new Error("Invalid asset address.");return new n.s(s)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,n.p)(e.address))throw new Error("native asset cannot be a wrapped asset");const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource((0,n.cR)(t),`${this.tokenBridgeAddress}::state::OriginInfo`),(0,n.cf)(this.chain,t)}async isTransferCompleted(e){const t=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data.consumed_vaas.elems.handle;try{return await this.connection.getTableItem(t,{key_type:"vector<u8>",value_type:"u8",key:`0x${n.Z.Buffer.from((0,n.cc)(e.hash)).toString("hex")}`}),!0}catch{return!1}}async getWrappedNative(){return(0,n.cf)(this.chain,n.m)}async*createAttestation(e,t){const s={chain:this.chain,address:new n.s(e)},r=await this.getAssetFullyQualifiedType(s);if(!r)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,type_arguments:[r],arguments:[]},"Aptos.AttestToken")}async*submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,type_arguments:[],arguments:[(0,n.bN)(e)]},"Aptos.CreateWrappedCoinType");const s=await this.getAssetFullyQualifiedType(e.payload.token);if(!s)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,type_arguments:[s],arguments:[(0,n.bN)(e)]},"Aptos.CreateWrappedCoin")}async*transfer(e,t,s,r,a){const i=0n,o=(0,n.p)(s)?n.m:s.toString(),d=t.address.toUniversalAddress().toUint8Array(),c=(0,n.a8)(t.chain);a?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,type_arguments:[o],arguments:[r,c,d,i,a]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,type_arguments:[o],arguments:[r,c,d,0n,i]},"Aptos.TransferTokens")}redeem(e,t){try{var s=this;return async function*(){const e=t.payload.token.chain===s.chain?await s.getTypeFromExternalAddress(t.payload.token.address.toString()):await s.getAssetFullyQualifiedType(t.payload.token);if(!e)throw new Error("Invalid asset address.");yield s.createUnsignedTx({function:`${s.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,type_arguments:[e],arguments:[(0,n.bN)(t)]},"Aptos.CompleteTransfer")}()}catch(e){return Promise.reject(e)}}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,n.cS)(e.address.toString())?e.address.toString():null:`${c.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{const t=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data,{handle:s}=t.native_infos,r=await this.connection.getTableItem(s,{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}});return r?[r.account_address,String.fromCharCode(...n.u.decode(r.module_name)),String.fromCharCode(...n.u.decode(r.struct_name))].join(n.r):null}catch{return null}}static getForeignAssetAddress(e,t,s){if((0,n.p)(s.address))throw new Error("Invalid token address");const r=(a={chain:s.chain,tokenBridgeAddress:new n.s(t).toUniversalAddress(),tokenId:s.address.toUniversalAddress()},(0,n.cP)(d,a));var a;return n.u.encode((0,n.cQ)(r),!0)}createUnsignedTx(e,t){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new o(e,this.network,this.chain,t,s)}}(0,n.bS)("Aptos","TokenBridge",c)}}]);
//# sourceMappingURL=921.c00e3acd.chunk.js.map