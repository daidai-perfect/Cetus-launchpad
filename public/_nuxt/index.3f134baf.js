import{ab as je}from"./entry.1afe32c4.js";import{a5 as Xe,a6 as Je,a7 as Ze,a8 as et,a9 as tt,aa as st,ab as at,ac as nt,ad as it,ae as ct,af as rt,ag as ot,V as lt,ah as ht,ai as ut,aj as dt,ak as pe,al as J,am as ft,W as pt,an as gt,ao as ge,ap as wt,aq as we,ar as K,X as me,as as Ee,at as ae,au as mt,av as yt,aw as ue,ax as _t,ay as vt,az as Ot,aA as St,aB as bt,aC as Ct,aD as kt,aE as Tt}from"./index.c41a185a.js";const $e="â€¦";function Mt(t){if(t.length<=6)return t;const e=t.startsWith("0x")?2:0;return`0x${t.slice(e,e+4)}${$e}${t.slice(-4)}`}function It(t){return`${t.slice(0,10)}${$e}`}const jt=/^([a-z0-9]+(?:-[a-z0-9]+)*)@([a-z0-9]+(?:-[a-z0-9]+)*)(?:\/v(\d+))?$/,ye=t=>jt.test(t),Be=t=>{const e=t.split(/::|<|>|,/);for(const s of e)if(s.includes("@")&&!ye(s))return!1;return!0},Et=Object.freeze(Object.defineProperty({__proto__:null,MIST_PER_SUI:Xe,MOVE_STDLIB_ADDRESS:Je,SUI_ADDRESS_LENGTH:Ze,SUI_CLOCK_OBJECT_ID:et,SUI_DECIMALS:tt,SUI_FRAMEWORK_ADDRESS:st,SUI_SYSTEM_ADDRESS:at,SUI_SYSTEM_MODULE_NAME:nt,SUI_SYSTEM_STATE_OBJECT_ID:it,SUI_TYPE_ARG:ct,formatAddress:Mt,formatDigest:It,fromB64:rt,fromHEX:ot,isValidNamedPackage:ye,isValidNamedType:Be,isValidSuiAddress:lt,isValidSuiNSName:ht,isValidSuiObjectId:ut,isValidTransactionDigest:dt,normalizeStructTag:pe,normalizeSuiAddress:J,normalizeSuiNSName:ft,normalizeSuiObjectId:pt,parseStructTag:gt,toB64:ge,toHEX:wt},Symbol.toStringTag,{value:"Module"}));var We=t=>{throw TypeError(t)},Pe=(t,e,s)=>e.has(t)||We("Cannot "+s),m=(t,e,s)=>(Pe(t,e,"read from private field"),s?s.call(t):e.get(t)),Ae=(t,e,s)=>e.has(t)?We("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),$t=(t,e,s,a)=>(Pe(t,e,"write to private field"),a?a.call(t,s):e.set(t,s),s),$,y;class xe{async getObject(e){const[s,a]=await Promise.all([this.get("OwnedObject",e),this.get("SharedOrImmutableObject",e)]);return s??a??null}async getObjects(e){return Promise.all([...e.map(s=>this.getObject(s))])}async addObject(e){return e.owner?await this.set("OwnedObject",e.objectId,e):await this.set("SharedOrImmutableObject",e.objectId,e),e}async addObjects(e){await Promise.all(e.map(async s=>this.addObject(s)))}async deleteObject(e){await Promise.all([this.delete("OwnedObject",e),this.delete("SharedOrImmutableObject",e)])}async deleteObjects(e){await Promise.all(e.map(s=>this.deleteObject(s)))}async getMoveFunctionDefinition(e){const s=`${J(e.package)}::${e.module}::${e.function}`;return this.get("MoveFunction",s)}async addMoveFunctionDefinition(e){const s=J(e.package),a=`${s}::${e.module}::${e.function}`,o={...e,package:s};return await this.set("MoveFunction",a,o),o}async deleteMoveFunctionDefinition(e){const s=`${J(e.package)}::${e.module}::${e.function}`;await this.delete("MoveFunction",s)}async getCustom(e){return this.get("Custom",e)}async setCustom(e,s){return this.set("Custom",e,s)}async deleteCustom(e){return this.delete("Custom",e)}}class Bt extends xe{constructor(){super(...arguments),Ae(this,$,{OwnedObject:new Map,SharedOrImmutableObject:new Map,MoveFunction:new Map,Custom:new Map})}async get(e,s){return m(this,$)[e].get(s)??null}async set(e,s,a){m(this,$)[e].set(s,a)}async delete(e,s){m(this,$)[e].delete(s)}async clear(e){if(e)m(this,$)[e].clear();else for(const s of Object.values(m(this,$)))s.clear()}}$=new WeakMap;class Ne{constructor({cache:e=new Bt}){Ae(this,y),$t(this,y,e)}asPlugin(){return async(e,s,a)=>{const o=e.inputs.filter(n=>n.UnresolvedObject).map(n=>n.UnresolvedObject.objectId),c=(await m(this,y).getObjects(o)).filter(n=>n!==null),i=new Map(c.map(n=>[n.objectId,n]));for(const n of e.inputs){if(!n.UnresolvedObject)continue;const h=i.get(n.UnresolvedObject.objectId);h&&(h.initialSharedVersion&&!n.UnresolvedObject.initialSharedVersion?n.UnresolvedObject.initialSharedVersion=h.initialSharedVersion:(h.version&&!n.UnresolvedObject.version&&(n.UnresolvedObject.version=h.version),h.digest&&!n.UnresolvedObject.digest&&(n.UnresolvedObject.digest=h.digest)))}await Promise.all(e.commands.map(async n=>{if(n.MoveCall){const h=await this.getMoveFunctionDefinition({package:n.MoveCall.package,module:n.MoveCall.module,function:n.MoveCall.function});h&&(n.MoveCall._argumentTypes=h.parameters)}})),await a(),await Promise.all(e.commands.map(async n=>{var h;(h=n.MoveCall)!=null&&h._argumentTypes&&await m(this,y).addMoveFunctionDefinition({package:n.MoveCall.package,module:n.MoveCall.module,function:n.MoveCall.function,parameters:n.MoveCall._argumentTypes})}))}}async clear(){await m(this,y).clear()}async getMoveFunctionDefinition(e){return m(this,y).getMoveFunctionDefinition(e)}async getObjects(e){return m(this,y).getObjects(e)}async deleteObjects(e){return m(this,y).deleteObjects(e)}async clearOwnedObjects(){await m(this,y).clear("OwnedObject")}async clearCustom(){await m(this,y).clear("Custom")}async getCustom(e){return m(this,y).getCustom(e)}async setCustom(e,s){return m(this,y).setCustom(e,s)}async deleteCustom(e){return m(this,y).deleteCustom(e)}async applyEffects(e){if(!e.V2)throw new Error(`Unsupported transaction effects version ${e.$kind}`);const{lamportVersion:s,changedObjects:a}=e.V2,o=[],c=[];a.map(async([i,n])=>{var h;if(n.outputState.NotExist)await m(this,y).deleteObject(i);else if(n.outputState.ObjectWrite){const[d,l]=n.outputState.ObjectWrite;c.push({objectId:i,digest:d,version:s,owner:l.AddressOwner??l.ObjectOwner??null,initialSharedVersion:((h=l.Shared)==null?void 0:h.initialSharedVersion)??null})}}),await Promise.all([m(this,y).addObjects(c),m(this,y).deleteObjects(o)])}}y=new WeakMap;var Ue=t=>{throw TypeError(t)},Re=(t,e,s)=>e.has(t)||Ue("Cannot "+s),z=(t,e,s)=>(Re(t,e,"read from private field"),s?s.call(t):e.get(t)),Ce=(t,e,s)=>e.has(t)?Ue("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),le=(t,e,s,a)=>(Re(t,e,"write to private field"),a?a.call(t,s):e.set(t,s),s),N,U;class Ve{constructor({client:e,...s}){Ce(this,N),Ce(this,U,null),le(this,N,e),this.cache=new Ne(s)}async reset(){await Promise.all([this.cache.clearOwnedObjects(),this.cache.clearCustom(),this.waitForLastTransaction()])}async buildTransaction({transaction:e,...s}){return e.addBuildPlugin(this.cache.asPlugin()),e.build({client:z(this,N),...s})}async executeTransaction({transaction:e,options:s,...a}){const o=we(e)?await this.buildTransaction({transaction:e}):e,c=await z(this,N).executeTransactionBlock({...a,transactionBlock:o,options:{...s,showRawEffects:!0}});if(c.rawEffects){const i=K.TransactionEffects.parse(Uint8Array.from(c.rawEffects));await this.applyEffects(i)}return c}async signAndExecuteTransaction({options:e,transaction:s,...a}){s.setSenderIfNotSet(a.signer.toSuiAddress());const o=await this.buildTransaction({transaction:s}),{signature:c}=await a.signer.signTransaction(o);return await this.executeTransaction({transaction:o,signature:c,options:e})}async applyEffects(e){var s;le(this,U,((s=e.V2)==null?void 0:s.transactionDigest)??null),await this.cache.applyEffects(e)}async waitForLastTransaction(){z(this,U)&&(await z(this,N).waitForTransaction({digest:z(this,U)}),le(this,U,null))}}N=new WeakMap;U=new WeakMap;var Ge=t=>{throw TypeError(t)},Wt=(t,e,s)=>e.has(t)||Ge("Cannot "+s),C=(t,e,s)=>(Wt(t,e,"read from private field"),s?s.call(t):e.get(t)),ze=(t,e,s)=>e.has(t)?Ge("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),I,B;class Fe{constructor(){ze(this,I,[])}async runTask(e){return new Promise((s,a)=>{C(this,I).push(()=>{e().finally(()=>{C(this,I).shift(),C(this,I).length>0&&C(this,I)[0]()}).then(s,a)}),C(this,I).length===1&&C(this,I)[0]()})}}I=new WeakMap;class Pt{constructor(e){ze(this,B,[]),this.activeTasks=0,this.maxTasks=e}runTask(e){return new Promise((s,a)=>{this.activeTasks<this.maxTasks?(this.activeTasks++,e().finally(()=>{C(this,B).length>0?C(this,B).shift()():this.activeTasks--}).then(s,a)):C(this,B).push(()=>{e().finally(()=>{C(this,B).length>0?C(this,B).shift()():this.activeTasks--}).then(s,a)})})}}B=new WeakMap;var De=t=>{throw TypeError(t)},Le=(t,e,s)=>e.has(t)||De("Cannot "+s),_=(t,e,s)=>(Le(t,e,"read from private field"),s?s.call(t):e.get(t)),x=(t,e,s)=>e.has(t)?De("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),he=(t,e,s,a)=>(Le(t,e,"write to private field"),a?a.call(t,s):e.set(t,s),s),Z,D,b,ee,de,te;class At{constructor({signer:e,defaultGasBudget:s=50000000n,...a}){x(this,Z,new Fe),x(this,D),x(this,b),x(this,ee),x(this,de,async o=>{if(!o.V2)return;const c=_e(o).ref;c?_(this,b).cache.setCustom("gasCoin",c):_(this,b).cache.deleteCustom("gasCoin")}),x(this,te,async o=>{const c=await _(this,b).cache.getCustom("gasCoin"),i=me.from(o);return c&&i.setGasPayment([c]),i.setGasBudgetIfNotSet(_(this,ee)),i.setSenderIfNotSet(_(this,D).toSuiAddress()),_(this,b).buildTransaction({transaction:i})}),he(this,D,e),he(this,ee,s),he(this,b,new Ve({client:a.client,cache:a.cache}))}async applyEffects(e){return Promise.all([_(this,de).call(this,e),_(this,b).cache.applyEffects(e)])}async buildTransaction(e){return _(this,Z).runTask(()=>_(this,te).call(this,e))}resetCache(){return _(this,b).reset()}waitForLastTransaction(){return _(this,b).waitForLastTransaction()}executeTransaction(e,s){return _(this,Z).runTask(async()=>{const a=we(e)?await _(this,te).call(this,e):e,{signature:o}=await _(this,D).signTransaction(a),c=await _(this,b).executeTransaction({signature:o,transaction:a,options:s}).catch(async h=>{throw await this.resetCache(),h}),i=Uint8Array.from(c.rawEffects),n=K.TransactionEffects.parse(i);return await this.applyEffects(n),{digest:c.digest,effects:ge(i),data:c}})}}Z=new WeakMap;D=new WeakMap;b=new WeakMap;ee=new WeakMap;de=new WeakMap;te=new WeakMap;function _e(t){if(!t.V2)throw new Error("Unexpected effects version");const e=t.V2.changedObjects[t.V2.gasObjectIndex];if(!e)throw new Error("Gas object not found in effects");const[s,{outputState:a}]=e;if(!a.ObjectWrite)throw new Error("Unexpected gas object state");const[o,c]=a.ObjectWrite;return{ref:{objectId:s,digest:o,version:t.V2.lamportVersion},owner:c.AddressOwner||c.ObjectOwner}}var qe=t=>{throw TypeError(t)},ve=(t,e,s)=>e.has(t)||qe("Cannot "+s),r=(t,e,s)=>(ve(t,e,"read from private field"),s?s.call(t):e.get(t)),w=(t,e,s)=>e.has(t)?qe("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),g=(t,e,s,a)=>(ve(t,e,"write to private field"),a?a.call(t,s):e.set(t,s),s),S=(t,e,s)=>(ve(t,e,"access private method"),s),ke=(t,e,s,a)=>({set _(o){g(t,e,o,s)},get _(){return r(t,e,a)}}),j,k,ne,q,L,Q,ie,V,v,E,P,W,Oe,se,Y,R,G,T,O,Qe,Ye,H,Se,He,fe,Ke;const F={coinBatchSize:20,initialCoinBalance:200000000n,minimumCoinBalance:50000000n,maxPoolSize:50,epochBoundaryWindow:1e3};class xt{constructor(e){w(this,O),w(this,j),w(this,k),w(this,ne),w(this,q),w(this,L),w(this,Q),w(this,ie),w(this,V),w(this,v),w(this,E,[]),w(this,P),w(this,W,new Map),w(this,Oe,new Fe),w(this,se),w(this,Y,null),w(this,R,null),w(this,G,0),w(this,T,null),g(this,j,e.signer),g(this,k,e.client),g(this,ne,e.coinBatchSize??F.coinBatchSize),g(this,q,e.initialCoinBalance??F.initialCoinBalance),g(this,L,e.minimumCoinBalance??F.minimumCoinBalance),g(this,ie,e.defaultGasBudget??r(this,L)),g(this,Q,e.epochBoundaryWindow??F.epochBoundaryWindow),g(this,V,e.maxPoolSize??F.maxPoolSize),g(this,P,new Ve({client:e.client,cache:e.cache})),g(this,se,new Pt(r(this,V))),g(this,v,e.sourceCoins?new Map(e.sourceCoins.map(s=>[s,null])):null)}resetCache(){return g(this,T,null),S(this,O,H).call(this,()=>r(this,P).reset())}async waitForLastTransaction(){await S(this,O,H).call(this,()=>S(this,O,Se).call(this))}async executeTransaction(e,s){const{promise:a,resolve:o,reject:c}=Nt(),i=await S(this,O,Qe).call(this,e),n=()=>{r(this,se).runTask(()=>S(this,O,Ye).call(this,e,i,s).then(o,c))},h=new Set;return i.forEach(d=>{r(this,W).get(d)?(h.add(d),r(this,W).get(d).push(()=>{h.delete(d),h.size===0&&n()})):r(this,W).set(d,[])}),h.size===0&&n(),a}}j=new WeakMap;k=new WeakMap;ne=new WeakMap;q=new WeakMap;L=new WeakMap;Q=new WeakMap;ie=new WeakMap;V=new WeakMap;v=new WeakMap;E=new WeakMap;P=new WeakMap;W=new WeakMap;Oe=new WeakMap;se=new WeakMap;Y=new WeakMap;R=new WeakMap;G=new WeakMap;T=new WeakMap;O=new WeakSet;Qe=async function(t){const e=new Set;let s=!1;return t.addSerializationPlugin(async(a,o,c)=>{await c(),!s&&(s=!0,a.inputs.forEach(i=>{var n,h,d,l,u;(h=(n=i.Object)==null?void 0:n.ImmOrOwnedObject)!=null&&h.objectId?e.add(i.Object.ImmOrOwnedObject.objectId):(l=(d=i.Object)==null?void 0:d.Receiving)!=null&&l.objectId?e.add(i.Object.Receiving.objectId):(u=i.UnresolvedObject)!=null&&u.objectId&&!i.UnresolvedObject.initialSharedVersion&&e.add(i.UnresolvedObject.objectId)}))}),await t.prepareForSerialization({client:r(this,k)}),e};Ye=async function(t,e,s){var o;let a;try{t.setSenderIfNotSet(r(this,j).toSuiAddress()),await r(this,Oe).runTask(async()=>{t.getData().gasData.price||t.setGasPrice(await S(this,O,fe).call(this)),t.setGasBudgetIfNotSet(r(this,ie)),await S(this,O,H).call(this),a=await S(this,O,He).call(this),ke(this,G)._++,t.setGasPayment([{objectId:a.id,version:a.version,digest:a.digest}]),await r(this,P).buildTransaction({transaction:t,onlyTransactionKind:!0})});const c=await t.build({client:r(this,k)}),{signature:i}=await r(this,j).signTransaction(c),n=await r(this,P).executeTransaction({transaction:c,signature:i,options:{...s,showEffects:!0}}),h=Uint8Array.from(n.rawEffects),d=K.TransactionEffects.parse(h),l=_e(d),u=(o=d.V2)==null?void 0:o.gasUsed;if(a&&u&&l.owner===r(this,j).toSuiAddress()){const p=BigInt(u.computationCost)+BigInt(u.storageCost)+BigInt(u.storageCost)-BigInt(u.storageRebate);let f=!1;new Ee(t.getData()).mapArguments(M=>(M.$kind==="GasCoin"&&(f=!0),M)),!f&&a.balance>=r(this,L)?r(this,E).push({id:l.ref.objectId,version:l.ref.version,digest:l.ref.digest,balance:a.balance-p}):(r(this,v)||g(this,v,new Map),r(this,v).set(l.ref.objectId,l.ref))}return g(this,Y,n.digest),{digest:n.digest,effects:ge(h),data:n}}catch(c){throw a&&(r(this,v)||g(this,v,new Map),r(this,v).set(a.id,null)),await S(this,O,H).call(this,async()=>{await Promise.all([r(this,P).cache.deleteObjects([...e]),S(this,O,Se).call(this)])}),c}finally{e.forEach(c=>{const i=r(this,W).get(c);i&&i.length>0?i.shift()():i&&r(this,W).delete(c)}),ke(this,G)._--}};H=async function(t){r(this,R)&&await r(this,R),g(this,R,(t==null?void 0:t().then(()=>{g(this,R,null)},()=>{}))??null)};Se=async function(){const t=r(this,Y);t&&(g(this,Y,null),await r(this,k).waitForTransaction({digest:t}))};He=async function(){if(r(this,E).length===0&&r(this,G)<=r(this,V)&&await S(this,O,Ke).call(this),r(this,E).length===0)throw new Error("No coins available");return r(this,E).shift()};fe=async function(){if((r(this,T)?r(this,T).expiration-r(this,Q)-Date.now():0)>0)return r(this,T).price;if(r(this,T)){const s=Math.max(r(this,T).expiration+r(this,Q)-Date.now(),1e3);await new Promise(a=>setTimeout(a,s))}const e=await r(this,k).getLatestSuiSystemState();return g(this,T,{price:BigInt(e.referenceGasPrice),expiration:Number.parseInt(e.epochStartTimestampMs,10)+Number.parseInt(e.epochDurationMs,10)}),S(this,O,fe).call(this)};Ke=async function(){var d;const t=Math.min(r(this,ne),r(this,V)-(r(this,E).length+r(this,G))+1);if(t===0)return;const e=new me,s=r(this,j).toSuiAddress();if(e.setSender(s),r(this,v)){const l=[],u=[];for(const[p,f]of r(this,v))f?l.push(f):u.push(p);if(u.length>0){const p=await r(this,k).multiGetObjects({ids:u});l.push(...p.filter(f=>f.data!==null).map(({data:f})=>({objectId:f.objectId,version:f.version,digest:f.digest})))}e.setGasPayment(l),g(this,v,new Map)}const a=new Array(t).fill(r(this,q)),o=e.splitCoins(e.gas,a),c=[];for(let l=0;l<a.length;l++)c.push(o[l]);e.transferObjects(c,s),await this.waitForLastTransaction();const i=await r(this,k).signAndExecuteTransaction({transaction:e,signer:r(this,j),options:{showRawEffects:!0}}),n=K.TransactionEffects.parse(Uint8Array.from(i.rawEffects));(d=n.V2)==null||d.changedObjects.forEach(([l,{outputState:u}],p)=>{var f;p===((f=n.V2)==null?void 0:f.gasObjectIndex)||!u.ObjectWrite||r(this,E).push({id:l,version:n.V2.lamportVersion,digest:u.ObjectWrite[0],balance:BigInt(r(this,q))})}),r(this,v)||g(this,v,new Map);const h=_e(n).ref;r(this,v).set(h.objectId,h),await r(this,k).waitForTransaction({digest:i.digest})};function Nt(){let t,e;return{promise:new Promise((a,o)=>{t=a,e=o}),resolve:t,reject:e}}const ce="CoinWithBalance",Te=pe("0x2::sui::SUI");function Ut({type:t=Te,balance:e,useGasCoin:s=!0}){return a=>{a.addIntentResolver(ce,Vt);const o=t==="gas"?t:pe(t);return a.add(ae.Intent({name:ce,inputs:{},data:{type:o===Te&&s?"gas":o,balance:BigInt(e)}}))}}const Rt=_t({type:vt(),balance:Ot()});async function Vt(t,e,s){var d,l;const a=new Set,o=new Map;if(!t.sender)throw new Error("Sender must be set to resolve CoinWithBalance");for(const u of t.commands)if(u.$kind==="$Intent"&&u.$Intent.name===ce){const{type:p,balance:f}=mt(Rt,u.$Intent.data);p!=="gas"&&a.add(p),o.set(p,(o.get(p)??0n)+f)}const c=new Set;for(const u of t.inputs)(d=u.Object)!=null&&d.ImmOrOwnedObject&&c.add(u.Object.ImmOrOwnedObject.objectId),(l=u.UnresolvedObject)!=null&&l.objectId&&c.add(u.UnresolvedObject.objectId);const i=new Map,n=yt(e);await Promise.all([...a].map(async u=>{i.set(u,await Gt({coinType:u,balance:o.get(u),client:n,owner:t.sender,usedIds:c}))}));const h=new Map;h.set("gas",{$kind:"GasCoin",GasCoin:!0});for(const[u,p]of t.commands.entries()){if(p.$kind!=="$Intent"||p.$Intent.name!==ce)continue;const{type:f,balance:M}=p.$Intent.data,X=[];if(!h.has(f)){const[A,...be]=i.get(f).map(oe=>t.addInput("object",ue.ObjectRef({objectId:oe.coinObjectId,digest:oe.digest,version:oe.version})));be.length>0&&X.push(ae.MergeCoins(A,be)),h.set(f,A)}X.push(ae.SplitCoins(h.get(f),[t.addInput("pure",ue.Pure(K.u64().serialize(M)))])),t.replaceCommand(u,X),t.mapArguments(A=>A.$kind==="Result"&&A.Result===u?{$kind:"NestedResult",NestedResult:[u+X.length-1,0]}:A)}return s()}async function Gt({coinType:t,balance:e,client:s,owner:a,usedIds:o}){let c=e;const i=[];return n();async function n(h=null){const{data:d,hasNextPage:l,nextCursor:u}=await s.getCoins({owner:a,coinType:t,cursor:h}),p=d.sort((f,M)=>Number(BigInt(M.balance)-BigInt(f.balance)));for(const f of p){if(o.has(f.coinObjectId))continue;const M=BigInt(f.balance);if(i.push(f),c-=M,c<=0)return i}if(l)return n(u);throw new Error(`Not enough coins of type ${t} to satisfy requested balance`)}}const zt={pure:St(t=>e=>e.pure(t)),object:bt(t=>e=>e.object(t)),sharedObjectRef:(...t)=>e=>e.sharedObjectRef(...t),objectRef:(...t)=>e=>e.objectRef(...t),receivingRef:(...t)=>e=>e.receivingRef(...t)},re="@",Ft=t=>{const e=new Set,s=new Set;for(const a of t.commands){if(!("MoveCall"in a))continue;const o=a.MoveCall;if(!o)continue;const c=o.package.split("::")[0];if(c.includes(re)){if(!ye(c))throw new Error(`Invalid package name: ${c}`);e.add(c)}for(const i of o.typeArguments??[])if(i.includes(re)){if(!Be(i))throw new Error(`Invalid type with names: ${i}`);s.add(i)}}return{packages:[...e],types:[...s]}},Dt=(t,e)=>{for(const s of t.commands){const a=s.MoveCall;if(!a)continue;const o=a.package.split("::"),c=o[0];if(c.includes(re)&&!e.packages[c])throw new Error(`No address found for package: ${c}`);o[0]=e.packages[c],a.package=o.join("::");const i=a.typeArguments;if(i){for(let n=0;n<i.length;n++)if(i[n].includes(re)){if(!e.types[i[n]])throw new Error(`No resolution found for type: ${i[n]}`);i[n]=e.types[i[n]]}a.typeArguments=i}}},Lt=(t,e)=>{const s=[],a=Me(t.packages),o=Me(t.types);for(const[c,i]of a.entries())s.push({id:c,type:"package",name:i});for(const[c,i]of o.entries())s.push({id:c+a.length,type:"moveType",name:i});return qt(s,e)},Me=t=>[...new Set(t)],qt=(t,e)=>{const s=[];for(let a=0;a<t.length;a+=e)s.push(t.slice(a,a+e));return s},Qt=({suiGraphQLClient:t,pageSize:e=10,overrides:s={packages:{},types:{}}})=>{const a={packages:{...s.packages},types:{...s.types}};return async(c,i,n)=>{const h=Ft(c),d=Lt({packages:h.packages.filter(l=>!a.packages[l]),types:h.types.filter(l=>!a.types[l])},e);(await Promise.all(d.map(l=>o(t,l)))).forEach(l=>{Object.assign(a.types,l.types),Object.assign(a.packages,l.packages)}),Dt(c,a),await n()};async function o(c,i){const n={packages:{},types:{}};if(i.length===0)return n;const h=`{
        ${i.map(l=>{const u=l.type==="package"?"packageByName":"typeByName",p=l.type==="package"?"address":"repr";return`${Ie(l.id)}: ${u}(name:"${l.name}") {
                    ${p}
                }`})}
    }`,d=await c.query({query:h,variables:void 0});if(d.errors)throw new Error(JSON.stringify({query:h,errors:d.errors}));for(const l of i){const u=Ie(l.id);if(!d.data||!d.data[u])throw new Error(`No result found for: ${l.name}`);const p=d.data[u];l.type==="package"&&(n.packages[l.name]=p.address),l.type==="moveType"&&(n.types[l.name]=p.repr)}return n}},Ie=t=>`key_${t}`,Yt=Object.freeze(Object.defineProperty({__proto__:null,Arguments:zt,AsyncCache:xe,Commands:ae,Inputs:ue,ObjectCache:Ne,ParallelTransactionExecutor:xt,SerialTransactionExecutor:At,Transaction:me,TransactionDataBuilder:Ee,UpgradePolicy:Ct,coinWithBalance:Ut,getPureBcsSchema:kt,isTransaction:we,namedPackagesPlugin:Qt,normalizedTypeToMoveTypeSignature:Tt},Symbol.toStringTag,{value:"Module"})),Xt=je(Et),Jt=je(Yt);export{Jt as a,Xt as r};
