import{m as bo,C as Uo,D as jo}from"./entry.7dcfbd3d.js";import{c as _,s as No,F as Ro,u as Eo,e as So,m as Q,p as uo,T as wo,G as fo,R as ro,n as ho,k as N,U as Mo,a3 as vo,a as Bo,g as Ao}from"./index.33b6d0c7.js";import{D as i}from"./decimal.0bdeb344.js";import{u as Fo}from"./useSuiAggregator.c36fc06e.js";import{i as Io,u as Vo,c as Lo,k as xo,p as _o}from"./pool.3fc49680.js";function yo(n){const y={launchpad:_[n||"Sui"].launchpad,ido:_[n||"Sui"].ido,xcetus:_[n||"Sui"].xcetus,xcetus_dividends:_[n||"Sui"].xcetus_dividends,cetus_faucet:_[n||"Sui"].cetus_faucet,xtoken:_[n||"Sui"].xtoken,xtoken_dividends:_[n||"Sui"].xtoken_dividends,token_faucet:_[n||"Sui"].token_faucet,booster:_[n||"Sui"].booster,maker_bonus:_[n||"Sui"].maker_bonus,liquidity_stratefy:_[n||"Sui"].liquidity_stratefy,vaults:_[n||"Sui"].vaults,frams:_[n||"Sui"].frams},b={fullRpcUrl:localStorage.getItem(`${n}-currentRpclocal6`)||_[n||"Sui"].fullRpcUrl,simulationAccount:_[n||"Sui"].simulationAccount,cetus_config:_[n||"Sui"].cetus_config,clmm_pool:_[n||"Sui"].clmm_pool,integrate:_[n||"Sui"].integrate,deepbook:_[n||"Sui"].deepbook,deepbook_endpoint_v2:_[n||"Sui"].deepbook_endpoint_v2,aggregatorUrl:_[n||"Sui"].aggregatorUrl},c=new No(b),l=new Ro(y,c),a=_.Sui.simulationAccount,B=bo(()=>({endPoint:_.Sui.aggregatorv2Url,fullNodeurl:localStorage.getItem("Sui-currentRpclocal6")||_.Sui.fullRpcUrl,walletAddress:K.value.address||a,env:Mo=="test"?vo.Testnet:vo.Mainnet,providers:["CETUS","DEEPBOOK","KRIYA","KRIYAV3","FLOWX","FLOWXV3","AFTERMATH","TURBOS","HAEDAL","VOLO","AFSUI"]})),{getFilterPoolsWithCoinAB:R}=Fo(),F=Io(),s=bo(()=>F),e=Eo(),K=bo(()=>e);Uo(()=>{K.value.address&&(c.senderAddress=K.value.address)});const T=async()=>{console.log(l,"sdk###");const o=await l.Vaults.getVaultList();return console.log("result.data:",o.data),o&&o.data||[]},to=async o=>{const r=await l.Vaults.getVault(o);return console.log(r,"vault##"),{...r,quota_based_type:So(r.quota_based_type).full_address}},no=async o=>{if(console.log(o,"###coinType"),c.senderAddress){const r=await l.ClmmSDK.fullClient.getBalance({owner:c.senderAddress,coinType:o});return r&&r.totalBalance}else return 0},Y=async()=>{try{if(c.senderAddress){const o=await l.ClmmSDK.fullClient.getAllBalances({owner:c.senderAddress});return console.log("ðŸš€ ~ file: useAutoPool.ts:95 ~ getAllBalances ~ allBalance:",o),o}else return[]}catch(o){console.log("ðŸš€ ~ file: useAutoPool.ts:102 ~ getAllBalances ~ error:",o)}},z=o=>({transactionBlock:o,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}}),f=async o=>{const{lowerTick:r,upperTick:g,slippage:q,rewarder_coin_types:L,isOnlyA:U,isOnlyB:x,currentTickIndex:d,decimal_b:E,request_id:k,stakeProtocol:Z,shouldRequestStake:A,farming_pool:O}=o;console.log(o,"params###");let S=o.fix_amount_a,u,h,v,C=d;const m=await l.ClmmSDK.Pool.getPool(o.clmm_pool);if(U||x){let P;try{P=await p({lowerTick:r,upperTick:g,curSqrtPrice:m.current_sqrt_price.toString(),fix_amount_a:o.fix_amount_a,input_amount:o.coinAmount,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,clmm_pool:o.clmm_pool,use_route:!0,slippage:q,request_id:k,stakeProtocol:Z,shouldRequestStake:A})}catch(G){console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:139 ~ deposit ~ e:",G)}console.log(P,"swapResut##211"),P?(h=new Q(P.afterSqrtPrice),u=P.fixAmountA===S?new Q(uo(o.coinAmount).sub(P.swapInAmount).toString()):new Q(P.swapOutAmount),v={swap_amount:P.swapInAmount,a2b:S,input_amount:o.coinAmount,route_obj:P.routeObj,stakeProtocol:P.stake_protocol},S=P.fixAmountA,C=wo.sqrtPriceX64ToTickIndex(new Q(P.afterSqrtPrice))):(h=new Q(o.curSqrtPrice),u=new Q(o.coinAmount))}else h=o.curSqrtPrice,u=new Q(o.coinAmount);let J,w,j;console.log(r,d,g,"####138"),C>=r&&C<=g?(J=fo.estLiquidityAndcoinAmountFromOneAmounts(r,g,u,S,!0,q,h),w=S?u.toString():J.tokenMaxA.toString(),j=S?J.tokenMaxB.toString():u.toString()):C<r?(w=u.toNumber(),j=0):C>g&&(w=0,j=u.toNumber()),console.log({lowerTick:r,upperTick:g,vault_id:o.id,clmm_pool:o.clmm_pool,farming_pool:O,lp_token_type:o.lp_token_type,amount_a:w,amount_b:j,fix_amount_a:S,slippage:q,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,swapParams:v},"params171");const X=await l.Vaults.deposit({lowerTick:r,upperTick:g,vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,amount_a:w,amount_b:j,fix_amount_a:S,slippage:q,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,swapParams:v,farming_pool:O,aggregatorConfig:B.value});return z(X)},t=async o=>{const{lowerTick:r,upperTick:g,coinTypeA:q,coinTypeB:L,receiveAmount:U,clmm_pool:x,lowerSqrtPrice:d,upperSqrtPrice:E,fix_amount_a:k,curSqrtPrice:Z,slippage:A,rewarder_coin_types:O,id:S,liquidity:u,swapParams:h,isOnlyA:v,isOnlyB:C,sliderVal:m,positionInfo:J,maxLiquidity:w,request_id:j,farming_pool:X}=o;console.log(m,"sliderVal##");const P=await to(S),G=await c.Pool.getPool(P.pool_id);let V,$,so,lo,W,eo,oo;const io=ro.get_share_liquidity_by_amount(P,m==100?J.balance:o.lpTokenAmount);if(console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:237 ~ remove ~ removeLiquidity:",{lowerTick:r,upperTick:g,curSqrtPrice:G.current_sqrt_price,fix_amount_a:k,receive_amount:U,coinTypeA:q,coinTypeB:L,clmm_pool:x,use_route:!0,slippage:A,removeLiquidity:m==100?io:"",maxLiquidity:w,request_id:j}),v||C){try{V=await D({lowerTick:r,upperTick:g,curSqrtPrice:G.current_sqrt_price,fix_amount_a:k,receiveAmount:U,coinTypeA:q,coinTypeB:L,clmm_pool:x,use_route:!0,slippage:A,liquidity:m==100?io:"",maxLiquidity:w,request_id:j})}catch(H){console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:257 ~ remove ~ e:",H)}if(console.log(V,"swapResut###"),V){const H=ro.get_share_liquidity_by_amount(P,J.balance);$=fo.getCoinAmountFromLiquidity(new Q(m==100?H:V.liquidity),new Q(G.current_sqrt_price),d,E,!1),so=ro.get_protocol_fee_amount(P,$.coinA.toString()),lo=ro.get_protocol_fee_amount(P,$.coinB.toString()),W=m==100?J.balance:ro.get_lp_amount_by_liquidity(P,V.liquidity),eo=uo($.coinA.toString()).mul(uo(1-o.slippage)),oo=uo($.coinB.toString()).mul(uo(1-o.slippage)),console.log(eo.toString(),"##minAmountA"),console.log(oo.toString(),"##minAmountA")}}else console.log(io,"#removeLiquidity"),$=fo.getCoinAmountFromLiquidity(new Q(io),new Q(G.current_sqrt_price),d,E,!1),console.log($,"#coinAmountscoinAmounts"),W=o.lpTokenAmount,eo=uo($.coinA.toString()).mul(uo(1-o.slippage)),oo=uo($.coinB.toString()).mul(uo(1-o.slippage)),console.log(so,lo,"##protocol_fee_amount_b"),console.log(eo.toString(),"##minAmountA"),console.log(oo.toString(),"##minAmountA"),console.log(o,"params###246");console.log(W,"lpTokenAmount remove");const M={vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,lp_token_amount:W,min_amount_a:ho(eo,0)||"",min_amount_b:ho(oo,0)||"",rewarder_coin_types:[],slippage:o.slippage,farming_pool:X,aggregatorConfig:B.value};console.log(M,"##removeParams"),(v||C)&&(M.swapParams={a2b:!k,swap_amount:V==null?void 0:V.swapInAmount,route_obj:V.routeObj});const ao=await l.Vaults.remove(M);return z(ao)},p=async o=>{var v,C;const{lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,input_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,slippage:k,decimals:Z,request_id:A,stakeProtocol:O,shouldRequestStake:S}=o;console.log(o,"params###");let u;const h=R((v=s==null?void 0:s.value)==null?void 0:v.poolListGroupByTokenAB,x,d);console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:378 ~ calculateDepositSwapAmount ~ pools:",h);try{if(u=await l.Vaults.calculateDepositSwapAmount({lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,input_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,use_route:!0,priceSplitPoint:k,request_id:A,stakeProtocol:O,shouldRequestStake:S,aggregatorConfig:B.value,pools:h},!0),console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:365 ~ calculateDepositSwapAmount ~ swapResut:",u),(C=u==null?void 0:u.routeObj)!=null&&C.isTimeout)throw new Error("router timeout")}catch(m){if(console.log(m,"calculateDepositSwapAmount error"),(String(m)=="Error: route unavailable"||String(m)=="Error: router timeout")&&(u=await l.Vaults.calculateDepositSwapAmount({lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,input_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,use_route:!1,priceSplitPoint:k,request_id:A,stakeProtocol:O,shouldRequestStake:S,aggregatorConfig:B.value,pools:h},!0),console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:387 ~ calculateDepositSwapAmount ~ swapResut:",u)),String(m)=="Error: HaedalStakeSuiAmountError")return"HaedalStakeSuiAmountError"}if(console.log(u,"##swapResut"),u){console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:384 ~ calculateDepositSwapAmount ~ swapResut.swapOutAmount:",u.swapOutAmount);const m=new i(u.swapOutAmount);return{...u,swapOutAmountLimit:N(m.sub(m.mul(k)).toNumber(),Z)}}return u},D=async o=>{var v,C;const{lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,receiveAmount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,slippage:k,decimals:Z,liquidity:A,maxLiquidity:O,request_id:S}=o;console.log({lowerTick:r,upperTick:g,curSqrtPrice:q.toString(),fix_amount_a:L,receive_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,use_route:!0,priceSplitPoint:k,removeLiquidity:A,maxLiquidity:O,request_id:S},"ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:415 ~ calculateRemoveSwapAmount ~ calculateRemoveSwapAmount");let u;const h=R((v=s==null?void 0:s.value)==null?void 0:v.poolListGroupByTokenAB,x,d);try{if(u=await l.Vaults.calculateRemoveSwapAmount({lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,receive_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,use_route:!0,priceSplitPoint:k,removeLiquidity:A,maxLiquidity:O,request_id:S,aggregatorConfig:B.value,pools:h}),console.log("ðŸš€ðŸš€ðŸš€ ~ file: useAutoPool.ts:426 ~ calculateRemoveSwapAmount ~ swapResut:",u,U),(C=u==null?void 0:u.routeObj)!=null&&C.isTimeout)throw new Error("router timeout")}catch(m){(String(m)=="Error: route unavailable"||String(m)=="Error: router timeout")&&(console.log(m,"e432"),u=await l.Vaults.calculateRemoveSwapAmount({lowerTick:r,upperTick:g,curSqrtPrice:q,fix_amount_a:L,receive_amount:U,coinTypeA:x,coinTypeB:d,clmm_pool:E,use_route:!1,priceSplitPoint:k,removeLiquidity:A,maxLiquidity:O,request_id:S,aggregatorConfig:B.value,pools:h}))}if(console.log(u,"###swapResut calculateRemoveSwapAmount"),u){const m=new i(u.swapOutAmount);return{...u,swapOutAmountLimit:N(m.sub(m.mul(k)).toNumber(),Z)}}return u};return{getAutoPools:T,getLpBalance:no,getAllBalances:Y,getVault:async o=>{const r=await l.Vaults.getVault(o);return console.log(r,"vault##292"),r},deposit:f,remove:t,getAutoPool:to,calculateDepositSwapAmount:p,calculateRemoveSwapAmount:D}}const Go=jo("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1",autoPoolLoading:!0}),getters:{getPoolStore(){return Vo()}},actions:{setApyObj(n){this.apyObj=n},setAutoPoolList(n){this.autoPoolList=n;const y=Object.fromEntries(n.map((b,c)=>[b.address,b]));this.autoPoolObj={...y}},async getAutoPoolList(){var F;const y=await yo("Sui").getAutoPools();console.log("ðŸš€ðŸš€ðŸš€ ~ file: autoPool.ts:35 ~ getAutoPoolList ~ list:",y),console.log(y,"list###");const b=this.getPoolStore,c=_.Sui.vaultFilter;let l;try{l=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(s=>s.json()),l.data&&l.data.pools&&l.data.pools.length>0&&(this.apyObj=Object.fromEntries(l.data.pools.map((s,e)=>[s.object_id,{...s,apr:s.apr.replace("%","")>0&&s.apr.replace("%","")<.01?"<0.01%":s.apr.replace("%","")<0?"--":N(s.apr.replace("%",""),2)+"%",resultApr:s.apr.replace("%","")}])),console.log(this.apyObj,"data##"))}catch{l=[],this.apyObj={}}console.log(l==null?void 0:l.data,"data##37");const a=((F=l==null?void 0:l.data)==null?void 0:F.pools)||[],B=a&&a.length>0?y.filter(s=>a.some(e=>e.object_id===s.id)):y;console.log(B,"##openPoolList");const R=(c?B:y).map(s=>{var T,to,no,Y,z,f,t;const e=b.poolConfigObj[s.pool_id];console.log("ðŸš€ðŸš€ðŸš€ ~ file: autoPool.ts:55 ~ autoPoolList ~ poolStore.poolConfigObj:",b.poolConfigObj),console.log("autoPoolList map",s,e);const K=[e!=null&&e.needReverse?(to=e==null?void 0:e.coinB)==null?void 0:to.address:(T=e==null?void 0:e.coinA)==null?void 0:T.address,e!=null&&e.needReverse?(Y=e==null?void 0:e.coinA)==null?void 0:Y.address:(no=e==null?void 0:e.coinB)==null?void 0:no.address];return(z=e==null?void 0:e.rewarderInfo)==null||z.forEach(p=>{p.emissionsEveryDay>0&&K.push(Bo(p.coinAddress))}),(t=(f=e==null?void 0:e.stable_farming)==null?void 0:f.stable_rewarder)==null||t.forEach(p=>{p.amount_second>0&&K.push(Bo(p.coin))}),{...e,token_a:e.coinA,token_b:e.coinB,id:s.id,lp_token_type:s.lp_token_type,autoPoolPositionInfo:s.position,is_pause:s.is_pause,total_supply:s.total_supply,liquidity:s.liquidity,protocol_fee_rate:s.protocol_fee_rate,max_quota:s.max_quota,stakeProtocol:s.stake_protocol,quota_based_type:So(s.quota_based_type).full_address,supportHaedalStake:!!s.stake_protocol,isTokenA:e!=null&&e.needReverse?(e==null?void 0:e.coin_b_address)=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI":(e==null?void 0:e.coin_a_address)=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",rewardList:Array.from(new Set(K))}});this.autoPoolObj=Object.fromEntries(R.map((s,e)=>[s.address,s])),this.autoPoolList=R,console.log(R,"##autoPoolList")},async getMyAutoPoolPosition(n){var K,T,to,no,Y,z;console.log("ðŸš€ ~ file: autoPool.ts:116 ~ getMyAutoPoolPosition ~ getMyAutoPoolPosition Start");const y=yo("Sui"),b=n||this.autoPoolList;console.log("ðŸš€ ~ file: autoPool.ts:119 ~ getMyAutoPoolPosition ~ list:",b);const c=Lo("Sui"),l=[],{RATES:a}=this.getPoolStore,B=b.map(f=>{var t;return(f==null?void 0:f.address)||((t=f==null?void 0:f.autoPoolPositionInfo)==null?void 0:t.clmm_pool_id)}),R=await c.getPools(B);console.log("ðŸš€ ~ file: autoPool.ts:129 ~ getMyAutoPoolPosition ~ newClmmPools:",R);const F=Object.fromEntries((K=Object.values(R))==null?void 0:K.map(f=>[f.poolAddress,f])),s=await y.getAllBalances();console.log("ðŸš€ ~ file: autoPool.ts:148 ~ getMyAutoPoolPosition ~ allBalance:",s);const e=Object.fromEntries(s==null?void 0:s.map(f=>[So(f.coinType).full_address,f]));for(let f=0;f<b.length;f++){const t=b[f];console.log(t,"poolINfo###");const p=F==null?void 0:F[t.address||t.autoPoolPositionInfo.clmm_pool_id];console.log("ðŸš€ ~ file: autoPool.ts:142 ~ getMyAutoPoolPosition ~ newPool:",p),console.log("ðŸš€ ~ file: autoPool.ts:148 ~ getMyAutoPoolPosition ~ poolInfo?.lp_token_type:",t==null?void 0:t.lp_token_type);const D=(T=e==null?void 0:e[So(t==null?void 0:t.lp_token_type).full_address])==null?void 0:T.totalBalance;console.log("ðŸš€ ~ file: autoPool.ts:148 ~ getMyAutoPoolPosition ~ balance:",D);const I=(await c.getTokenListByCoinType([b[f].lp_token_type]))[0];console.log("ðŸš€ ~ file: autoPool.ts:154 ~ getMyAutoPoolPosition ~ lpInfo:",I);const o=((to=a[t.coinA.address])==null?void 0:to.price)||0,r=((no=a[t.coinB.address])==null?void 0:no.price)||0,g=t.autoPoolPositionInfo.tick_lower_index,q=t.autoPoolPositionInfo.tick_upper_index,L=Number(D)>0?ro.get_share_liquidity_by_amount({...t,liquidity:t==null?void 0:t.liquidity,total_supply:t==null?void 0:t.total_supply},D):0;console.log("ðŸš€ ~ file: autoPool.ts:159 ~ getMyAutoPoolPosition ~ liquidity:",L);const U={tick_lower_index:g,tick_upper_index:q,current_sqrt_price:p==null?void 0:p.current_sqrt_price,liquidity:L};console.log(t,"poolInfo##94");const x=c.getCoinAmountFromLiquidity({pool:{...t,current_sqrt_price:p==null?void 0:p.current_sqrt_price},position:U,roundUp:!1});console.log(x,"##amountInfo");const d=x.coinaAmount,E=x.coinbAmount,k=d,Z=E,A=t.coinA.decimals,O=t.coinB.decimals,S=c.TickMath.tickIndexToPrice(Number(g),A,O).toString(),u=c.TickMath.tickIndexToPrice(Number(q),A,O).toString(),h=d>0?new i(o).mul(new i(d)).toNumber():0,v=E>0?new i(r).mul(new i(E)).toNumber():0,C=h>0&&h<.01?"<$0.01":`$${Ao(N(h,2))}`,m=v>0&&v<.01?"<$0.01":`$${Ao(N(v,2))}`,J=wo.sqrtPriceX64ToPrice(p.current_sqrt_price,A,O),w=c.getCoinAmountFromLiquidity({pool:{...t,tick_lower_index:g,tick_upper_index:q,current_sqrt_price:p==null?void 0:p.current_sqrt_price},position:{...U,liquidity:t.liquidity},roundUp:!1}),j=new i(w.coinaAmount).toNumber(),X=new i(w.coinbAmount).toNumber();console.log(j,X,J.toString(),"###116");const P=N(new i(j).mul(new i(o)).toNumber(),2),G=N(new i(X).mul(new i(r)).toNumber(),2);console.log(p,"newPool##"),console.log(j,X,o,r,Number(P)+Number(G),"###poolCoinBNum");const{ratioA:V,ratioB:$}=ro.calculateDepositRatio(g,q,new Q.BN(p==null?void 0:p.current_sqrt_price));console.log(V,$.toString(),"###139");const so=V.mul(100).toNumber().toFixed(0),lo=100-Number(so);console.log(j,X,so,lo,"###147");let W=0;Number(D)>0&&(W=new i(D).div(Math.pow(10,I.decimals))),console.log("ðŸš€ ~ file: autoPool.ts:234 ~ getMyAutoPoolPosition ~ myLiquidity:",W.toString());const eo=new i(h).add(new i(v)).toNumber(),oo=o&&r?eo>0&&eo<.01?"<0.01":N(new i(h).add(new i(v)).toString(),2):"--",io=t.total_supply;let M=0;W>0&&io>0&&(M=new i(W).mul(Math.pow(10,I.decimals)).div(new i(io)).mul(100).toNumber()),console.log(M,"##myShare");const ao=new i(1).div(Math.pow(10,t.decimals)).toNumber();let H=0;if(M>1)H=N(M,2);else if(M>0&&M<ao)H=`<${ao}`;else if(M==0)H=0;else{const To=xo(M),Do=To==-1?2:To+2;H=N(M,Do)}console.log(D,W.toString(),"###balance");const co=(await c.getTokenListByCoinType([t.quota_based_type]))[0],mo=_o(t.max_quota,co.decimals);console.log(t.quota_based_type,co,mo,"##quoteCoinInfo");const po=co.address==t.coin_b_address,go=po?new i(w.coinaAmount).mul(t.price).add(w.coinbAmount):new i(w.coinaAmount).mul(1/t.price).add(w.coinbAmount),Oo=((Y=a[co.address])==null?void 0:Y.price)||0,qo=go.mul(new i(Oo)).toNumber();console.log(po,qo,"#isQuotaCoin");const Po=mo,Co=po?new i(w.coinaAmount).mul(t.price).add(w.coinbAmount):new i(w.coinaAmount).mul(1/t.price).add(w.coinbAmount),ko=new i(Po).sub(Co).mul(r).toNumber();console.log(ko,"remainingTokenUSD##"),console.log(go.toNumber(),"#poolTokenNum"),this.positionInfoObj[t.id]={tick_lower_index:g,tick_upper_index:q,current_sqrt_price:p.current_sqrt_price,myLiquidity:_o(D,I.decimals),amountA:k,amountB:Z,...t,lpInfo:I,myAmountAUSD:C,myAmountBUSD:m,myLiquidityUSD:oo,myShare:H,minPrice:S,maxPrice:u,poolCoinARatio:so,poolCoinBRatio:lo,poolCoinANum:j,poolCoinBNum:X,poolCoinAUSD:P,poolCoinBUSD:G,quoteUSD:Po,balance:D,quoteCoinInfo:co,remainingTokenUSD:ko,currentDeposit:qo,positionLiquidity:L,total_supply:t.total_supply},l.push({tick_lower_index:g,tick_upper_index:q,current_sqrt_price:(z=t==null?void 0:t.object)==null?void 0:z.current_sqrt_price,myLiquidity:_o(D,I.decimals),amountA:k,amountB:Z,...t,lpInfo:I,myAmountAUSD:C,myAmountBUSD:m,myLiquidityUSD:oo,myShare:H,minPrice:S,maxPrice:u,poolCoinARatio:so,poolCoinBRatio:lo,poolCoinANum:j,poolCoinBNum:X,poolCoinAUSD:P,poolCoinBUSD:G,quoteUSD:Po,balance:D,total_supply:t.total_supply})}this.positionInfoList=l,this.autoPoolLoading=!1,console.log(this.positionInfoObj,"this.positionInfoObj###"),console.log(this.positionInfoList,"###this.positionInfoList")},async updatePositionItem(n){var oo,io,M,ao,H,co,mo;console.log("ðŸš€ ~ file: autoPool.ts:116  ~ updatePositionItem Start");const y=yo("Sui"),b=Lo("Sui"),c=await y.getAutoPool(n);console.log("ðŸš€ðŸš€ðŸš€ ~ file: autoPool.ts:318 ~ updatePositionItem ~ newPoolInfo:",c);const l=await b.getPool(c.address||c.position.clmm_pool_id);console.log("newPoolInfo:",c),console.log("newPool:",l),console.log("this.positionInfoObj[id]:",this.positionInfoObj[n]);const a={...this.positionInfoObj[n],autoPoolPositionInfo:c.position,...l},B=await y.getLpBalance(a.lp_token_type);console.log(B,"updatePositionItem lp balance");const R=(await b.getTokenListByCoinType([a.lp_token_type]))[0];console.log(B,"###balance updatePositionItem");const F=a.autoPoolPositionInfo.tick_lower_index,s=a.autoPoolPositionInfo.tick_upper_index;let e;c.total_supply==0?e=0:e=ro.get_share_liquidity_by_amount(c,String(B)),console.log(e,"##liquidity");const K={tick_lower_index:F,tick_upper_index:s,current_sqrt_price:l.current_sqrt_price,liquidity:e},T=b.getCoinAmountFromLiquidity({pool:{current_sqrt_price:l.current_sqrt_price,...a},position:K,roundUp:!1}),to=T.coinaAmount,no=T.coinbAmount,{RATES:Y}=this.getPoolStore,z=c.total_supply,f=wo.sqrtPriceX64ToPrice(l.current_sqrt_price,(oo=a==null?void 0:a.coinA)==null?void 0:oo.decimals,(io=a==null?void 0:a.coinB)==null?void 0:io.decimals),t=2,p=2,D=((ao=Y[(M=a==null?void 0:a.coinA)==null?void 0:M.address])==null?void 0:ao.price)||0,I=((co=Y[(H=a==null?void 0:a.coinB)==null?void 0:H.address])==null?void 0:co.price)||0,o=(T==null?void 0:T.coinaAmount)>0?new i(D).mul(new i(T==null?void 0:T.coinaAmount)).toNumber():0,r=(T==null?void 0:T.coinbAmount)>0?new i(I).mul(new i(T==null?void 0:T.coinbAmount)).toNumber():0,g=o>0&&o<.01?"<$0.01":`$${Ao(N(o,2))}`,q=r>0&&r<.01?"<$0.01":`$${Ao(N(r,2))}`;let L=new i(0);Number(B)>0&&(L=new i(B).div(Math.pow(10,R==null?void 0:R.decimals)),console.log("ðŸš€ðŸš€ðŸš€ ~ file: autoPool.ts:379 ~ updatePositionItem ~ myLiquidity:",L.toString()));const U=new i(o).add(new i(r)).toNumber(),x=D&&I?U>0&&U<.01?"<0.01":N(new i(o).add(new i(r)).toString(),2):"--";let d=0;L.toNumber()>0&&z>0&&(d=new i(L).mul(Math.pow(10,R.decimals)).div(new i(z)).mul(100).toNumber()),console.log(d,"##myShare");const E=new i(1).div(Math.pow(10,a.decimals)).toNumber();let k=0;if(d>1)k=N(d,2);else if(d>0&&d<E)k=`<${E}`;else if(d==0)k=0;else{const po=xo(d),go=po==-1?2:po+2;k=N(d,go)}const Z=wo.sqrtPriceX64ToPrice(l.current_sqrt_price,t,p),A=await b.getCoinAmountFromLiquidity({pool:{...a,tick_lower_index:F,tick_upper_index:s,current_sqrt_price:l==null?void 0:l.current_sqrt_price},position:{...K,liquidity:c.liquidity},roundUp:!1}),O=new i(A.coinaAmount).toNumber(),S=new i(A.coinbAmount).toNumber();console.log(O,S,Z.toString(),"###116");const u=N(new i(O).mul(new i(D)).toNumber(),2),h=N(new i(S).mul(new i(I)).toNumber(),2);console.log(l,"newPool##"),console.log(O,S,D,I,Number(u)+Number(h),"###poolCoinBNum");const{ratioA:v,ratioB:C}=ro.calculateDepositRatio(F,s,new Q.BN(l==null?void 0:l.current_sqrt_price));console.log(v,C.toString(),"###139");const m=v.mul(100).toNumber().toFixed(0),J=100-Number(m),w=(await b.getTokenListByCoinType([c.quota_based_type]))[0],j=_o(c.max_quota,w.decimals);console.log(c.quota_based_type,w,j,"##quoteCoinInfo");const X=w.address==a.coin_b_address,P=X?new i(A.coinaAmount).mul(a.price).add(A.coinbAmount):new i(A.coinaAmount).mul(1/a.price).add(A.coinbAmount),G=((mo=Y[w.address])==null?void 0:mo.price)||0,V=P.mul(new i(G)).toNumber(),$=j,so=X?new i(A.coinaAmount).mul(a.price).add(A.coinbAmount):new i(A.coinaAmount).mul(1/a.price).add(A.coinbAmount),lo=new i($).sub(so).mul(I).toNumber();console.log(lo,"remainingTokenUSD##");const W=b.TickMath.tickIndexToPrice(Number(F),t,p).toString(),eo=b.TickMath.tickIndexToPrice(Number(s),t,p).toString();this.positionInfoObj[n]={...a,tick_lower_index:F,tick_upper_index:s,current_sqrt_price:l.current_sqrt_price,myLiquidity:_o(B,R==null?void 0:R.decimals),amountA:to,amountB:no,myShare:k,myAmountAUSD:g,myAmountBUSD:q,myLiquidityUSD:x,poolCoinARatio:m,poolCoinBRatio:J,poolCoinANum:O,poolCoinBNum:S,poolCoinAUSD:u,poolCoinBUSD:h,quoteUSD:$,balance:B,price:f,quoteCoinInfo:w,remainingTokenUSD:lo,currentDeposit:V,positionLiquidity:e,liquidity:c==null?void 0:c.liquidity,minPrice:W,maxPrice:eo,total_supply:c.total_supply},this.autoPoolLoading=!1,console.log(this.positionInfoObj[n],"###this.positionInfoObj[id]")},async getAutoPoolAPY(){try{const{data:n}=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(y=>y.json());n&&n.pools&&n.pools.length>0&&(this.apyObj=Object.fromEntries(n.pools.map((y,b)=>[y.object_id,{...y,apr:y.apr.replace("%","")>0&&y.apr.replace("%","")<.01?"<0.01%":N(y.apr.replace("%",""),2)+"%",resultApr:y.apr.replace("%","")}])),console.log(this.apyObj,"data##"))}catch{this.apyObj={}}},async getVault(n,y){const b=yo("Sui");y||(this.autoPoolLoading=!0);const{status:c}=await b.getVault(n);this.currentAutoPoolStatus=c,this.updatePositionItem(n),console.log(c,"status##")},setSlippage(n){console.log(n,"slippage##"),this.slippage=n,localStorage.setItem("cetus-auto-slippage",n)},logout(){this.getMyAutoPoolPosition(),this.positionUSDObj={}}}});export{yo as a,Go as u};
